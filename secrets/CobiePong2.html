<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>CobiePong - Trippy Edition</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: 'Segoe UI', Arial, sans-serif;
    }

    #game-wrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* --- FIXED Z-LAYERING --- */
    #trippy {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      display: block;
    }

    #three-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      display: block;
    }

    #crt-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: overlay;
      opacity: 0.3;
      z-index: 2;
      background-image:
        repeating-linear-gradient(
          to bottom,
          rgba(0,0,0,0.65),
          rgba(0,0,0,0.65) 1px,
          rgba(0,0,0,0.0) 3px
        ),
        radial-gradient(circle at center, rgba(255,255,255,0.15), rgba(0,0,0,0.95));
    }

    #vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 2;
      background: radial-gradient(circle at center, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
    }

    #score {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
      font-weight: bold;
      color: white;
      text-shadow: 0 0 15px rgba(120,200,255,0.9);
      z-index: 3;
      pointer-events: none;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      background: rgba(0,0,20,0.6);
      backdrop-filter: blur(6px);
    }

    .hidden { display:none; }

    .title-row {
      display:flex;
      gap:4px;
      margin-bottom:20px;
    }
    .title-letter {
      font-size:72px;
      font-weight:900;
      animation:bob 1.2s ease-in-out infinite;
      text-shadow:0 0 15px;
    }
    @keyframes bob {
      0%,100% { transform:translateY(0);}
      50% { transform:translateY(-10px);}
    }

    .menu-option {
      margin: 10px;
      padding: 10px 25px;
      background: rgba(255,255,255,0.1);
      border-radius:12px;
      font-size:28px;
      cursor:pointer;
      transition:0.2s;
    }
    .menu-option.selected {
      background: rgba(255,255,255,0.3);
      transform:scale(1.05);
    }

    .hint-text {
      margin-top:20px;
      font-size:22px;
      opacity:0.8;
      animation: hintPulse 2s infinite;
    }
    @keyframes hintPulse {
      0%,100% { opacity:0.6;}
      50%     { opacity:1;}
    }
  </style>
</head>
<body>
<div id="game-wrapper">

  <!-- SECRET2-TRIPPY BACKGROUND CANVAS -->
  <canvas id="trippy"></canvas>

  <!-- THREE.JS -->
  <canvas id="three-canvas"></canvas>
  <div id="crt-overlay"></div>
  <div id="vignette"></div>

  <div id="score">0 : 0</div>

  <!-- MENU -->
  <div id="menu-overlay" class="overlay">
    <div class="title-row" id="cobie-title"></div>
    <div class="menu-option selected" data-mode="0">Player vs CPU</div>
    <div class="menu-option" data-mode="1">Player1 vs Player2</div>
    <div class="hint-text">Press ENTER to play</div>
  </div>

  <!-- GAME OVER -->
  <div id="gameover-overlay" class="overlay hidden">
    <div class="gameover-title" id="gameover-title" style="font-size:64px;font-weight:900;color:white;">GAME OVER</div>
    <div class="gameover-sub" id="gameover-sub" style="font-size:32px;margin-top:10px;">Nice!</div>
    <div style="margin-top:25px;font-size:22px;opacity:0.8;">Press ENTER for menu</div>
  </div>

</div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>
/* =========================================================
   SECRET2 — ORIGINAL TRIPPY BACKGROUND EFFECT (FIXED)
   ========================================================= */

const bg = document.getElementById("trippy");
const ctx = bg.getContext("2d");

function resizeBG() {
  bg.width = window.innerWidth;
  bg.height = window.innerHeight;
  bg.style.width = window.innerWidth + "px";
  bg.style.height = window.innerHeight + "px";
}
resizeBG();
window.addEventListener("resize", resizeBG);

let t = 0;
let shockwave = 0;

function triggerBgShock(power = 40) {
  shockwave = Math.min(shockwave + power, 120);
}

function drawBG() {
  ctx.fillStyle = "rgba(0,0,0,0.09)";
  ctx.fillRect(0, 0, bg.width, bg.height);

  const cx = bg.width / 2;
  const cy = bg.height / 2;

  for (let i = 0; i < 60; i++) {
    let angle = t * 0.002 + i * 0.14;
    let radius = (i * 15) + Math.sin(t * 0.008 + i) * 10 + shockwave;

    let x = cx + Math.cos(angle) * radius;
    let y = cy + Math.sin(angle * 1.7) * radius * 0.6;

    let r = 8 + Math.sin(t * 0.018 + i) * 4 + shockwave * 0.05;
    let hue = (t * 0.3 + i * 12 + shockwave * 0.4) % 360;

    ctx.beginPath();
    ctx.fillStyle = `hsla(${hue},85%,60%,0.8)`;
    ctx.shadowColor = `hsla(${(hue+50)%360},90%,70%,0.9)`;
    ctx.shadowBlur = 35;
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  shockwave *= 0.92;
  t++;
  requestAnimationFrame(drawBG);
}
drawBG();

/* ============================================================
   =============== THREE.JS GAME (FOLGT IN TEIL 2) ============
   ============================================================ */


  /* ============================================================
   ===============   THREE.JS GAME START   =====================
   ============================================================ */

//
// Title letters
//
const cobieTitle = document.getElementById("cobie-title");
const titleStr = "CobiePong";
const colors = ["#4285F4", "#EA4335", "#FBBC05", "#34A853", "#A142F4"];
for (let i = 0; i < titleStr.length; i++) {
  const span = document.createElement("span");
  span.className = "title-letter";
  span.textContent = titleStr[i];
  span.style.color = colors[i % colors.length];
  cobieTitle.appendChild(span);
}

//
// GAME STATE
//
let gameState = "menu";   // "menu" | "playing" | "gameover"
let gameMode   = 0;       // 0 vs CPU, 1 vs Player
let menuIndex  = 0;
let score = { p1:0, p2:0 };
let WIN_SCORE = 5;

const menuOverlay     = document.getElementById("menu-overlay");
const gameoverOverlay = document.getElementById("gameover-overlay");
const scoreDisplay    = document.getElementById("score");
const gameoverTitle   = document.getElementById("gameover-title");
const gameoverSub     = document.getElementById("gameover-sub");

const menuOptions = [...document.querySelectorAll(".menu-option")];
function updateMenu() {
  menuOptions.forEach((o,i)=> o.classList.toggle("selected", i===menuIndex));
}
updateMenu();

//
// THREE.JS SETUP
//
const canvas3D = document.getElementById("three-canvas");
const renderer = new THREE.WebGLRenderer({canvas: canvas3D, antialias:true});
renderer.setPixelRatio(Math.min(1.5, window.devicePixelRatio));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 15, 30);

const camera = new THREE.PerspectiveCamera(
  50, window.innerWidth/window.innerHeight, 0.1, 200
);
camera.position.set(0, 8, 16);
camera.lookAt(0,0,0);

//
// LIGHTS
//
scene.add(new THREE.AmbientLight(0xffffff, 0.4));

const l1 = new THREE.SpotLight(0x52c7ff, 1.5);
l1.position.set(-8,16,0);
l1.target.position.set(-4,0,0);
scene.add(l1, l1.target);

const l2 = new THREE.SpotLight(0xff52a9, 1.5);
l2.position.set(8,16,0);
l2.target.position.set(4,0,0);
scene.add(l2, l2.target);

//
// STARFIELD
//
const starGeo = new THREE.BufferGeometry();
const starCount = 1200;
const starsPos = new Float32Array(starCount*3);
for(let i=0;i<starsPos.length;i+=3){
  starsPos[i]   = (Math.random()-0.5)*120;
  starsPos[i+1] = (Math.random()-0.5)*60;
  starsPos[i+2] = (Math.random()-0.5)*120;
}
starGeo.setAttribute("position", new THREE.BufferAttribute(starsPos,3));
const starMat = new THREE.PointsMaterial({color:0xffffff,size:0.12});
const stars = new THREE.Points(starGeo, starMat);
scene.add(stars);

//
// FIELD + WALLS
//
const FIELD_W = 16;
const FIELD_H = 9;

const field = new THREE.Mesh(
  new THREE.PlaneGeometry(FIELD_W, FIELD_H),
  new THREE.MeshStandardMaterial({
    color:0x06090f, metalness:0.7, roughness:0.25,
    emissive:0x0b1a33, emissiveIntensity:0.25
  })
);
field.rotation.x = -Math.PI/2;
scene.add(field);

const midLine = new THREE.Mesh(
  new THREE.PlaneGeometry(0.08, FIELD_H),
  new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.4})
);
midLine.position.set(0,0.02,0);
midLine.rotation.x = -Math.PI/2;
scene.add(midLine);

//
// WALLS
//
const wallMat = new THREE.MeshStandardMaterial({
  color:0x284c9a,
  metalness:0.8,
  roughness:0.25,
  emissive:0x1a2f66,
  emissiveIntensity:1.4
});
const wallH = 0.5;
const wallT = 0.3;

const wallTop = new THREE.Mesh(new THREE.BoxGeometry(FIELD_W, wallH, wallT), wallMat);
wallTop.position.set(0, wallH/2, -FIELD_H/2);

const wallBottom = wallTop.clone();
wallBottom.position.set(0, wallH/2, FIELD_H/2);

const wallLeft = new THREE.Mesh(new THREE.BoxGeometry(wallT, wallH, FIELD_H), wallMat);
wallLeft.position.set(-FIELD_W/2, wallH/2, 0);

const wallRight = wallLeft.clone();
wallRight.position.set(FIELD_W/2, wallH/2, 0);

scene.add(wallTop, wallBottom, wallLeft, wallRight);

//
// PADDLES
//
const paddleW = 0.4;
const paddleH = 2;
const paddleD = 0.4;

const paddleGeom = new THREE.BoxGeometry(paddleW, paddleD, paddleH);

const mat1 = new THREE.MeshStandardMaterial({
  color:0x52c7ff,
  emissive:0x115577,
  emissiveIntensity:1.4
});
const mat2 = new THREE.MeshStandardMaterial({
  color:0xff52a9,
  emissive:0x551133,
  emissiveIntensity:1.4
});

const p1Mesh = new THREE.Mesh(paddleGeom, mat1);
const p2Mesh = new THREE.Mesh(paddleGeom, mat2);

p1Mesh.position.set(-FIELD_W/2 + 1, paddleD/2, 0);
p2Mesh.position.set( FIELD_W/2 - 1, paddleD/2, 0);

scene.add(p1Mesh, p2Mesh);

//
// BALL
//
const ballR = 0.25;
const ball = new THREE.Mesh(
  new THREE.SphereGeometry(ballR,32,32),
  new THREE.MeshStandardMaterial({
    color:0xffffff,
    emissive:0x44aaff,
    emissiveIntensity:2.2
  })
);
ball.position.y = ballR + 0.1;
scene.add(ball);

let bx=0,bz=0, bvx=0.15, bvz=0;

// Reset mit zufälligem Winkel
function resetBall(dir=1){
  bx=0; bz=0;
  const a = (Math.random()*Math.PI/2) - Math.PI/4;
  bvx = Math.cos(a)*0.15*dir;
  bvz = Math.sin(a)*0.15;
}

resetBall(1);

//
// TRAIL
//
const trailCount = 22;
const trail = [];
let trailIdx = 0;
const trailCols = [0x52c7ff,0x44aaff,0x3688ff,0x2866ff];

for(let i=0;i<trailCount;i++){
  const m = new THREE.Mesh(
    new THREE.SphereGeometry(ballR*0.85,16,16),
    new THREE.MeshBasicMaterial({
      color: trailCols[Math.floor(i/(trailCount/4))],
      transparent:true,
      opacity:0
    })
  );
  scene.add(m);
  trail.push(m);
}

function updateTrail(){
  const tmesh = trail[trailIdx];
  tmesh.position.copy(ball.position);
  tmesh.material.opacity = 0.9;
  tmesh.scale.set(1,1,1);

  trailIdx = (trailIdx+1)%trailCount;

  for(let i=0;i<trailCount;i++){
    if(i===trailIdx) continue;
    const m = trail[i];
    m.material.opacity *= 0.83;
    m.scale.multiplyScalar(0.94);
  }
}

//
// EXPLOSION PARTICLES (3D)
//
let explosions=[];
function spawnExplosion(x,z,c1=0x55ccff,c2=0xff55aa){
  for(let i=0;i<28;i++){
    const g=new THREE.SphereGeometry(0.12,8,8);
    const m=new THREE.MeshBasicMaterial({
      color:(i%2?c2:c1),
      transparent:true,
      opacity:1
    });
    const s=new THREE.Mesh(g,m);
    s.position.set(x, ballR+0.15, z);
    scene.add(s);

    explosions.push({
      mesh:s,
      vx:(Math.random()-0.5)*0.35,
      vy:(Math.random()*0.15)+0.02,
      vz:(Math.random()-0.5)*0.35,
      life:0.9+Math.random()*0.4
    });
  }
}

function updateExplosions(dt){
  for(let i=explosions.length-1;i>=0;i--){
    const e=explosions[i];
    e.life-=dt;
    if(e.life<=0){
      scene.remove(e.mesh);
      explosions.splice(i,1);
      continue;
    }
    e.mesh.position.x+=e.vx;
    e.mesh.position.z+=e.vz;
    e.mesh.position.y+=e.vy;
    e.vy -= 0.005;

    e.mesh.material.opacity = e.life*1.3;
    e.mesh.scale.multiplyScalar(0.97);
  }
}

//
// RINGS
//
const ring1 = new THREE.Mesh(
  new THREE.TorusGeometry(FIELD_W/2.2,0.03,16,80),
  new THREE.MeshBasicMaterial({color:0x334477,transparent:true,opacity:0.6})
);
ring1.rotation.x=Math.PI/2;
scene.add(ring1);

const ring2 = new THREE.Mesh(
  new THREE.TorusGeometry(FIELD_W/3,0.03,16,80),
  new THREE.MeshBasicMaterial({color:0x223355,transparent:true,opacity:0.45})
);
ring2.rotation.x=Math.PI/2;
scene.add(ring2);

//
// GAME LOGIC
//
let keys={};
document.addEventListener("keydown",e=>{
  keys[e.key]=true;

  if(gameState==="menu"){
    if(e.key==="ArrowUp"||e.key==="ArrowDown"){
      menuIndex = menuIndex===0?1:0;
      updateMenu();
    }
    if(e.key==="Enter"){
      gameMode = menuIndex;
      score={p1:0,p2:0};
      scoreDisplay.textContent = "0 : 0";
      resetBall(1);
      menuOverlay.classList.add("hidden");
      gameoverOverlay.classList.add("hidden");
      gameState="playing";
    }
  }

  if(gameState==="gameover" && e.key==="Enter"){
    gameState="menu";
    menuOverlay.classList.remove("hidden");
    gameoverOverlay.classList.add("hidden");
  }
});
document.addEventListener("keyup",e=>keys[e.key]=false);

let p1z=0,p2z=0;
let hits=0;
let camShake=0;

function paddleBounce(left){
  const pz = left? p1z : p2z;
  const rel = (bz - pz)/(paddleH/2);
  const ang = Math.max(-1, Math.min(1,rel))*Math.PI/3;
  const dir = left?1:-1;

  bvx = Math.cos(ang)*0.15*dir;
  bvz = Math.sin(ang)*0.15;

  hits++;
  camShake=0.3;

  spawnExplosion(bx,bz, left?0x55ccff:0xff55aa);
  triggerBgShock(70);
}

function updateGame(dt){
  // P1 movement
  const speed=0.22;
  if(keys["w"]) p1z-=speed;
  if(keys["s"]) p1z+=speed;

  const lim= FIELD_H/2 - paddleH/2;
  p1z = Math.max(-lim,Math.min(lim,p1z));

  // CPU or P2
  if(gameMode===1){
    if(keys["ArrowUp"])   p2z-=speed;
    if(keys["ArrowDown"]) p2z+=speed;
  } else {
    let cs = 0.18;
    if(bz < p2z-0.2) p2z-=cs;
    if(bz > p2z+0.2) p2z+=cs;
  }
  p2z=Math.max(-lim,Math.min(lim,p2z));

  // move ball
  const mult = hits<=5? 1+hits*0.2 : (hits<10? 2:3);
  bx+=bvx*mult;
  bz+=bvz*mult;

  // walls Z
  const topZ    = -FIELD_H/2 + ballR;
  const bottomZ =  FIELD_H/2 - ballR;

  if(bz<topZ){
    bz=topZ;
    bvz*=-1;
    spawnExplosion(bx,topZ);
    triggerBgShock(30);
    camShake=0.2;
  }
  if(bz>bottomZ){
    bz=bottomZ;
    bvz*=-1;
    spawnExplosion(bx,bottomZ);
    triggerBgShock(30);
    camShake=0.2;
  }

  // paddles
  const p1x = -FIELD_W/2 + 1;
  const p2x =  FIELD_W/2 - 1;
  const pw = paddleW/2 + ballR;

  if(bvx<0 && Math.abs(bx-p1x)<pw && Math.abs(bz-p1z)<paddleH/2) paddleBounce(true);
  if(bvx>0 && Math.abs(bx-p2x)<pw && Math.abs(bz-p2z)<paddleH/2) paddleBounce(false);

  // scoring
  if(bx < -FIELD_W/2 - 1){
    score.p2++;
    scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
    if(score.p2>=WIN_SCORE) endGame(false);
    else resetBall(1);
  }
  if(bx > FIELD_W/2 + 1){
    score.p1++;
    scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
    if(score.p1>=WIN_SCORE) endGame(true);
    else resetBall(-1);
  }

  // update mesh positions
  p1Mesh.position.z = p1z;
  p2Mesh.position.z = p2z;
  ball.position.set(bx, ballR+0.1, bz);

  updateTrail();
  updateExplosions(dt);

  // camera shake
  if(camShake>0){
    camera.position.x = (Math.random()-0.5)*camShake;
    camera.position.y = 8 + (Math.random()-0.5)*camShake;
    camShake-=dt*2;
  } else {
    camera.position.x=0;
    camera.position.y=8;
  }
  camera.lookAt(0,0,0);
}

function endGame(p1Won){
  gameState="gameover";
  if(p1Won){
    gameoverTitle.textContent = "Player 1 Won!";
    gameoverSub.textContent   = "Nice reflexes!";
  } else {
    if(gameMode===0){
      gameoverTitle.textContent = "You lost vs CPU!";
      gameoverSub.textContent   = "Try harder!";
    } else {
      gameoverTitle.textContent = "Player 2 Won!";
      gameoverSub.textContent   = "Good match!";
    }
  }
  gameoverOverlay.classList.remove("hidden");
}

//
// MAIN LOOP
//
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  const time= clock.getElapsedTime();

  midLine.material.opacity = 0.4 + 0.2*Math.sin(time*3);
  stars.rotation.y += 0.0002;

  ring1.rotation.y += 0.002;
  ring2.rotation.y -= 0.0015;

  if(gameState==="playing") updateGame(dt);

  renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>

