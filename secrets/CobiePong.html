<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>CobiePong</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #050509;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    #game-wrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    canvas#three-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Score oben zentriert */
    #score {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 5;
    }

    /* Shared Overlay-Styling (Menu & Game Over) */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(255,255,255,0.08), rgba(0,0,0,0.9));
      z-index: 10;
    }

    .hidden {
      display: none;
    }

    /* CobiePong Titel */
    .title-row {
      display: flex;
      gap: 4px;
      margin-bottom: 18px;
      perspective: 800px;
    }

    .title-letter {
      font-size: 64px;
      font-weight: 900;
      display: inline-block;
      animation: bob 1.2s ease-in-out infinite;
      transform-origin: center bottom;
      text-shadow: 0 0 10px rgba(0,0,0,0.7);
    }

    /* leichte zeitliche Versätze für Wippen */
    .title-letter:nth-child(1) { animation-delay: 0s; }
    .title-letter:nth-child(2) { animation-delay: 0.08s; }
    .title-letter:nth-child(3) { animation-delay: 0.16s; }
    .title-letter:nth-child(4) { animation-delay: 0.24s; }
    .title-letter:nth-child(5) { animation-delay: 0.32s; }
    .title-letter:nth-child(6) { animation-delay: 0.40s; }
    .title-letter:nth-child(7) { animation-delay: 0.48s; }
    .title-letter:nth-child(8) { animation-delay: 0.56s; }
    .title-letter:nth-child(9) { animation-delay: 0.64s; }

    @keyframes bob {
      0%,100% {
        transform: translateY(0) rotateX(0deg);
      }
      50% {
        transform: translateY(-8px) rotateX(8deg);
      }
    }

    .menu-option {
      font-size: 26px;
      margin: 6px 0;
      padding: 4px 14px;
      border-radius: 999px;
      cursor: pointer;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.1);
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }

    .menu-option span {
      background: linear-gradient(90deg, #ff5252, #ffd452, #4dff4d, #52c7ff, #d452ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .menu-option.selected {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 0 18px rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.06);
    }

    .hint-text {
      margin-top: 20px;
      font-size: 18px;
      letter-spacing: 1px;
      text-shadow: 0 0 6px rgba(0,0,0,0.7);
    }

    .hint-text span {
      background: linear-gradient(90deg, #ffd452, #ff5252, #d452ff, #52c7ff, #4dff4d);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    /* Game Over Text */
    .gameover-title {
      font-size: 42px;
      font-weight: 800;
      margin-bottom: 12px;
      text-align: center;
      text-shadow: 0 0 10px rgba(0,0,0,0.9);
    }

    .gameover-sub {
      font-size: 20px;
      opacity: 0.9;
      margin-bottom: 28px;
      text-align: center;
    }

    .gameover-hint {
      font-size: 18px;
      opacity: 0.8;
    }

    @media (max-width: 768px) {
      .title-letter { font-size: 44px; }
      .menu-option { font-size: 20px; }
      .gameover-title { font-size: 32px; }
    }
  </style>

  <!-- Three.js von CDN -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
</head>
<body>
<div id="game-wrapper">
  <canvas id="three-canvas"></canvas>

  <div id="score">0 : 0</div>

  <!-- Start-Menü -->
  <div id="menu-overlay" class="overlay">
    <div class="title-row" id="cobie-title"></div>
    <div class="menu-option selected" data-mode="0"><span>Player vs CPU</span></div>
    <div class="menu-option" data-mode="1"><span>Player1 vs Player2</span></div>
    <div class="hint-text"><span>Press ENTER To Play</span></div>
  </div>

  <!-- Game Over -->
  <div id="gameover-overlay" class="overlay hidden">
    <div class="gameover-title" id="gameover-title">Player 1 Won!</div>
    <div class="gameover-sub" id="gameover-sub">Great job!</div>
    <div class="gameover-hint">Press ENTER to go back to menu</div>
  </div>
</div>

<script>
  // ---------- Titel "CobiePong" bunt + wippend ----------
  const cobieTitle = document.getElementById("cobie-title");
  const cobieText = "CobiePong";
  const colorPalette = ["#4285F4", "#EA4335", "#FBBC05", "#34A853", "#A142F4"]; // Google/eBay-Style

  for (let i = 0; i < cobieText.length; i++) {
    const span = document.createElement("span");
    span.className = "title-letter";
    span.textContent = cobieText[i];
    span.style.color = colorPalette[i % colorPalette.length];
    cobieTitle.appendChild(span);
  }

  // ---------- Game State ----------
  let gameState = "menu"; // "menu" | "playing" | "gameover"
  let gameMode = 0;       // 0 = PvCPU, 1 = PvP
  let menuIndex = 0;
  const WIN_SCORE = 5;

  const menuOverlay = document.getElementById("menu-overlay");
  const gameoverOverlay = document.getElementById("gameover-overlay");
  const gameoverTitle = document.getElementById("gameover-title");
  const gameoverSub = document.getElementById("gameover-sub");
  const scoreDisplay = document.getElementById("score");
  const menuOptions = Array.from(document.querySelectorAll(".menu-option"));

  function updateMenuVisual() {
    menuOptions.forEach((opt, i) => {
      opt.classList.toggle("selected", i === menuIndex);
    });
  }

  // ---------- Three.js Setup ----------
  const canvas = document.getElementById("three-canvas");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x05060b);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 8, 16);
  camera.lookAt(0, 0, 0);

  // Licht
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const spot = new THREE.SpotLight(0x66ccff, 1.2, 50, Math.PI / 4, 0.4, 1.5);
  spot.position.set(0, 15, 8);
  spot.target.position.set(0, 0, 0);
  scene.add(spot);
  scene.add(spot.target);

  // Spielfeld (Plane)
  const FIELD_WIDTH = 16;
  const FIELD_HEIGHT = 9;

  const fieldGeom = new THREE.PlaneGeometry(FIELD_WIDTH, FIELD_HEIGHT);
  const fieldMat = new THREE.MeshStandardMaterial({
    color: 0x10131f,
    metalness: 0.3,
    roughness: 0.6
  });
  const field = new THREE.Mesh(fieldGeom, fieldMat);
  field.rotation.x = -Math.PI / 2;
  scene.add(field);

  // Mittellinie als dünnes Plane-Objekt
  const midLineGeom = new THREE.PlaneGeometry(0.08, FIELD_HEIGHT);
  const midLineMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    opacity: 0.4,
    transparent: true
  });
  const midLine = new THREE.Mesh(midLineGeom, midLineMat);
  midLine.position.set(0, 0.01, 0);  // leicht über dem Feld
  midLine.rotation.x = -Math.PI / 2;
  scene.add(midLine);

  // Ränder als leuchtende Barrieren
  const wallMat = new THREE.MeshStandardMaterial({
    color: 0x222a4d,
    emissive: 0x111133,
    metalness: 0.5,
    roughness: 0.4
  });
  const wallThickness = 0.3;
  const wallHeight = 0.4;
  const wallGeomH = new THREE.BoxGeometry(FIELD_WIDTH, wallHeight, wallThickness);
  const wallGeomV = new THREE.BoxGeometry(wallThickness, wallHeight, FIELD_HEIGHT);

  const wallTop = new THREE.Mesh(wallGeomH, wallMat);
  wallTop.position.set(0, wallHeight/2, -FIELD_HEIGHT/2);
  const wallBottom = wallTop.clone();
  wallBottom.position.set(0, wallHeight/2, FIELD_HEIGHT/2);

  const wallLeft = new THREE.Mesh(wallGeomV, wallMat);
  wallLeft.position.set(-FIELD_WIDTH/2, wallHeight/2, 0);
  const wallRight = wallLeft.clone();
  wallRight.position.set(FIELD_WIDTH/2, wallHeight/2, 0);

  scene.add(wallTop, wallBottom, wallLeft, wallRight);

  // Paddles
  const paddleWidth = 0.4;
  const paddleHeight = 2.0;
  const paddleDepth = 0.4;

  const paddleGeom = new THREE.BoxGeometry(paddleWidth, paddleDepth, paddleHeight);
  const paddleMat1 = new THREE.MeshStandardMaterial({ 
    color: 0x52c7ff, 
    emissive: 0x113344,
    metalness: 0.7,
    roughness: 0.2
  });
  const paddleMat2 = new THREE.MeshStandardMaterial({ 
    color: 0xff52a9, 
    emissive: 0x441122,
    metalness: 0.7,
    roughness: 0.2
  });

  const paddle1Mesh = new THREE.Mesh(paddleGeom, paddleMat1);
  const paddle2Mesh = new THREE.Mesh(paddleGeom, paddleMat2);

  paddle1Mesh.position.set(-FIELD_WIDTH/2 + 1.0, paddleDepth/2, 0);
  paddle2Mesh.position.set(FIELD_WIDTH/2 - 1.0, paddleDepth/2, 0);

  scene.add(paddle1Mesh, paddle2Mesh);

  // Ball
  const ballRadius = 0.25;
  const ballGeom = new THREE.SphereGeometry(ballRadius, 32, 32);
  const ballMat = new THREE.MeshStandardMaterial({
    color: 0xFFFFFF,
    emissive: 0x3388ff,
    metalness: 0.5,
    roughness: 0.3
  });
  const ballMesh = new THREE.Mesh(ballGeom, ballMat);
  ballMesh.position.set(0, ballRadius + 0.1, 0);
  scene.add(ballMesh);

  // Hintergrund-Deko: ein paar rotierende „Neon-Ringe“
  const ringGeom = new THREE.TorusGeometry(FIELD_WIDTH/2.2, 0.03, 16, 100);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x333366 });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI/2;
  ring.position.y = 0.02;
  scene.add(ring);

  const ring2Geom = new THREE.TorusGeometry(FIELD_WIDTH/3, 0.02, 16, 100);
  const ring2Mat = new THREE.MeshBasicMaterial({ color: 0x223344 });
  const ring2 = new THREE.Mesh(ring2Geom, ring2Mat);
  ring2.rotation.x = Math.PI/2;
  ring2.position.y = 0.03;
  scene.add(ring2);

  // Partikel-Effekte
  const particleCount = 20;
  const particles = [];
  const particleGeometry = new THREE.BufferGeometry();
  const particleMaterial = new THREE.PointsMaterial({
    color: 0x66ccff,
    size: 0.1,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false
  });

  const particlePositions = new Float32Array(particleCount * 3);
  for (let i = 0; i < particleCount * 3; i++) {
    particlePositions[i] = (Math.random() - 0.5) * 10;
  }
  particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
  const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
  scene.add(particleSystem);

  // ---------- Spiel-Logik (im 2D-Raum: X/Z) ----------

  let keys = {};

  // Logik-Koordinaten = World-Koordinaten in X/Z-Ebene
  let p1 = { z: 0 };
  let p2 = { z: 0 };

  let ball = { x: 0, z: 0, vx: 0.12, vz: 0.09 };
  let hitCount = 0;
  let score = { p1: 0, p2: 0 };
  let cameraShake = 0;

  function calculateSpeedMultiplier(hitCount) {
    if (hitCount <= 5) {
      return 1 + hitCount * 0.2; // bis +100%
    }
    if (hitCount < 10) {
      return 2.0; // +100%
    }
    return 3.0; // +200%
  }

  function resetBall(direction = 1) {
    ball.x = 0;
    ball.z = 0;
    hitCount = 0;
    const baseSpeedX = 0.12;
    const baseSpeedZ = 0.09;
    const dirX = direction >= 0 ? 1 : -1;
    ball.vx = baseSpeedX * dirX;
    ball.vz = (Math.random() > 0.5 ? 1 : -1) * baseSpeedZ;
  }

  function resetGameToMenu() {
    score.p1 = 0;
    score.p2 = 0;
    scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
    p1.z = 0;
    p2.z = 0;
    resetBall(1);
    gameState = "menu";
    menuOverlay.classList.remove("hidden");
    gameoverOverlay.classList.add("hidden");
  }

  function createParticles(x, y, z, count) {
    for (let i = 0; i < count; i++) {
      const particleGeom = new THREE.SphereGeometry(0.05, 8, 8);
      const particleMat = new THREE.MeshBasicMaterial({
        color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
        transparent: true,
        opacity: 0.8
      });
      const particle = new THREE.Mesh(particleGeom, particleMat);
      particle.position.set(x, y, z);
      particle.userData.velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.2,
        Math.random() * 0.1,
        (Math.random() - 0.5) * 0.2
      );
      particle.userData.life = 1.0;
      scene.add(particle);
      particles.push(particle);
    }
  }

  function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.userData.life -= 0.03;
      p.position.add(p.userData.velocity);
      p.scale.multiplyScalar(0.95);
      p.material.opacity = p.userData.life;
      
      if (p.userData.life <= 0) {
        scene.remove(p);
        particles.splice(i, 1);
      }
    }
  }

  resetBall(1);

  // Eingaben
  document.addEventListener("keydown", (e) => {
    keys[e.key] = true;

    if (gameState === "menu") {
      if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        menuIndex = menuIndex === 0 ? 1 : 0;
        updateMenuVisual();
      }
      if (e.key === "Enter") {
        gameMode = menuIndex; // 0 oder 1
        menuOverlay.classList.add("hidden");
        gameoverOverlay.classList.add("hidden");
        gameState = "playing";
        resetBall(1);
      }
    } else if (gameState === "gameover") {
      if (e.key === "Enter") {
        resetGameToMenu();
      }
    }
  });

  document.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  function updateGame() {
    const paddleSpeed = 0.22;

    // Player 1 (links)
    if (keys["w"]) p1.z -= paddleSpeed;
    if (keys["s"]) p1.z += paddleSpeed;

    // Begrenzung
    const maxZ = FIELD_HEIGHT/2 - paddleHeight/2;
    p1.z = Math.max(-maxZ, Math.min(maxZ, p1.z));

    // Player 2
    if (gameMode === 1) {
      // Mensch
      if (keys["ArrowUp"]) p2.z -= paddleSpeed;
      if (keys["ArrowDown"]) p2.z += paddleSpeed;
      p2.z = Math.max(-maxZ, Math.min(maxZ, p2.z));
    } else {
      // CPU – einfache KI
      const cpuSpeed = 0.18;
      if (ball.z < p2.z - 0.2) p2.z -= cpuSpeed;
      if (ball.z > p2.z + 0.2) p2.z += cpuSpeed;
      p2.z = Math.max(-maxZ, Math.min(maxZ, p2.z));
    }

    // Ballbewegung mit Multiplikator
    const speedMult = calculateSpeedMultiplier(hitCount);
    ball.x += ball.vx * speedMult;
    ball.z += ball.vz * speedMult;

    // Kollision mit oberen/unteren Wänden (Z)
    const topZ = -FIELD_HEIGHT/2 + ballRadius;
    const bottomZ = FIELD_HEIGHT/2 - ballRadius;
    if (ball.z < topZ || ball.z > bottomZ) {
      ball.vz *= -1;
      createParticles(ball.x, ballRadius + 0.1, ball.z, 5);
    }

    // Paddles X-Positionen:
    const p1X = -FIELD_WIDTH/2 + 1.0;
    const p2X = FIELD_WIDTH/2 - 1.0;

    // Paddle-Kollisionsbereich
    function checkPaddleCollision(px, pz) {
      const paddleHalfH = paddleHeight/2;
      const paddleHalfW = paddleWidth/2 + ballRadius;
      const withinZ = ball.z > (pz - paddleHalfH) && ball.z < (pz + paddleHalfH);
      const closeX = Math.abs(ball.x - px) < paddleHalfW;
      return withinZ && closeX;
    }

    if (checkPaddleCollision(p1X, p1.z) && ball.vx < 0) {
      ball.vx *= -1;
      hitCount++;
      createParticles(ball.x, ballRadius + 0.1, ball.z, 8);
      // Paddle-Feedback
      paddle1Mesh.material.emissive.setHex(0x44aaff);
      setTimeout(() => {
        paddle1Mesh.material.emissive.setHex(0x113344);
      }, 100);
    }

    if (checkPaddleCollision(p2X, p2.z) && ball.vx > 0) {
      ball.vx *= -1;
      hitCount++;
      createParticles(ball.x, ballRadius + 0.1, ball.z, 8);
      // Paddle-Feedback
      paddle2Mesh.material.emissive.setHex(0xff44aa);
      setTimeout(() => {
        paddle2Mesh.material.emissive.setHex(0x441122);
      }, 100);
    }

    // Punkte (links/rechts verlassen)
    if (ball.x < -FIELD_WIDTH/2 - 1) {
      // Punkt für Player 2
      score.p2++;
      scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
      cameraShake = 0.5;
      checkWinOrContinue(-1);
    } else if (ball.x > FIELD_WIDTH/2 + 1) {
      // Punkt für Player 1
      score.p1++;
      scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
      cameraShake = 0.5;
      checkWinOrContinue(1);
    }

    // Meshes updaten
    paddle1Mesh.position.z = p1.z;
    paddle2Mesh.position.z = p2.z;
    ballMesh.position.set(ball.x, ballRadius + 0.1, ball.z);
  }

  function checkWinOrContinue(lastDirection) {
    if (score.p1 >= WIN_SCORE || score.p2 >= WIN_SCORE) {
      // Game Over
      gameState = "gameover";
      let msg = "";
      let sub = "";
      if (score.p1 > score.p2) {
        msg = "Player 1 Won!";
        sub = "Nice reflexes!";
      } else {
        if (gameMode === 0) {
          msg = "You loose against an CPU!";
          sub = "Try Harder!";
        } else {
          msg = "Player 2 Won!";
          sub = "Well played!";
        }
      }
      gameoverTitle.textContent = msg;
      gameoverSub.textContent = sub;
      gameoverOverlay.classList.remove("hidden");
    } else {
      // weiter spielen, Ball zurücksetzen, gleiche Richtung optional
      resetBall(-lastDirection);
    }
  }

  // ---------- Animation Loop ----------
  function animate() {
    requestAnimationFrame(animate);

    // kleine Dekoration: Ringe rotieren lassen
    ring.rotation.y += 0.0015;
    ring2.rotation.y -= 0.001;

    // Partikel updaten
    updateParticles();

    // Camera Shake
    if (cameraShake > 0) {
      camera.position.x = (Math.random() - 0.5) * cameraShake;
      camera.position.y = 8 + (Math.random() - 0.5) * cameraShake;
      camera.position.z = 16 + (Math.random() - 0.5) * cameraShake;
      cameraShake *= 0.9;
      camera.lookAt(0, 0, 0);
    } else if (gameState === "playing") {
      camera.position.set(0, 8, 16);
      camera.lookAt(0, 0, 0);
    }

    if (gameState === "playing") {
      updateGame();
    }

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
</script>
</body>
</html>
