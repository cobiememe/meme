<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>CobiePong - Enhanced</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #050509;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }

    #game-wrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
    }

    canvas#three-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Score oben zentriert */
    #score {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 42px;
      font-weight: 900;
      text-shadow: 0 0 15px rgba(100, 200, 255, 0.8);
      pointer-events: none;
      z-index: 5;
      letter-spacing: 4px;
      background: linear-gradient(90deg, #ff5252, #ffd452, #4dff4d, #52c7ff, #d452ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: scorePulse 2s ease-in-out infinite alternate;
    }

    @keyframes scorePulse {
      0% { transform: translateX(-50%) scale(1); }
      100% { transform: translateX(-50%) scale(1.05); }
    }

    /* CRT / Scanline Overlay */
    #crt-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: overlay;
      opacity: 0.3;
      z-index: 4;
      background-image:
        repeating-linear-gradient(
          to bottom,
          rgba(0,0,0,0.65),
          rgba(0,0,0,0.65) 1px,
          rgba(0,0,0,0.0) 3px
        ),
        radial-gradient(circle at center, rgba(255,255,255,0.12), rgba(0,0,0,0.95));
    }

    /* Vignette-Effekt */
    #vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 3;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 60%, rgba(0,0,0,0.7) 100%);
    }

    /* Shared Overlay-Styling (Menu & Game Over) */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at center, rgba(0, 30, 60, 0.7) 0%, rgba(0, 0, 0, 0.95) 70%);
      z-index: 10;
      backdrop-filter: blur(5px);
    }

    .hidden {
      display: none;
    }

    /* CobiePong Titel */
    .title-row {
      display: flex;
      gap: 4px;
      margin-bottom: 28px;
      perspective: 800px;
    }

    .title-letter {
      font-size: 72px;
      font-weight: 900;
      display: inline-block;
      animation: bob 1.2s ease-in-out infinite;
      transform-origin: center bottom;
      text-shadow: 0 0 20px currentColor;
      filter: drop-shadow(0 0 8px rgba(255,255,255,0.5));
    }

    .title-letter:nth-child(1) { animation-delay: 0s; }
    .title-letter:nth-child(2) { animation-delay: 0.08s; }
    .title-letter:nth-child(3) { animation-delay: 0.16s; }
    .title-letter:nth-child(4) { animation-delay: 0.24s; }
    .title-letter:nth-child(5) { animation-delay: 0.32s; }
    .title-letter:nth-child(6) { animation-delay: 0.40s; }
    .title-letter:nth-child(7) { animation-delay: 0.48s; }
    .title-letter:nth-child(8) { animation-delay: 0.56s; }
    .title-letter:nth-child(9) { animation-delay: 0.64s; }

    @keyframes bob {
      0%,100% {
        transform: translateY(0) rotateX(0deg);
      }
      50% {
        transform: translateY(-12px) rotateX(8deg);
      }
    }

    .menu-option {
      font-size: 28px;
      margin: 10px 0;
      padding: 8px 24px;
      border-radius: 999px;
      cursor: pointer;
      background: rgba(0,0,0,0.6);
      border: 2px solid rgba(255,255,255,0.15);
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .menu-option::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.5s;
    }

    .menu-option:hover::before {
      left: 100%;
    }

    .menu-option span {
      background: linear-gradient(90deg, #ff5252, #ffd452, #4dff4d, #52c7ff, #d452ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-weight: 600;
    }

    .menu-option.selected {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 0 25px rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.1);
      border-color: rgba(255,255,255,0.4);
    }

    .hint-text {
      margin-top: 30px;
      font-size: 20px;
      letter-spacing: 1px;
      text-shadow: 0 0 8px rgba(0,0,0,0.7);
      animation: hintPulse 3s ease-in-out infinite;
    }

    @keyframes hintPulse {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    .hint-text span {
      background: linear-gradient(90deg, #ffd452, #ff5252, #d452ff, #52c7ff, #4dff4d);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    /* Game Over Text */
    .gameover-title {
      font-size: 52px;
      font-weight: 800;
      margin-bottom: 20px;
      text-align: center;
      text-shadow: 0 0 20px rgba(0,0,0,0.9);
      background: linear-gradient(90deg, #ff5252, #ffd452, #4dff4d, #52c7ff, #d452ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: gameoverPulse 2s ease-in-out infinite alternate;
    }

    @keyframes gameoverPulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.05); }
    }

    .gameover-sub {
      font-size: 24px;
      opacity: 0.9;
      margin-bottom: 40px;
      text-align: center;
    }

    .gameover-hint {
      font-size: 20px;
      opacity: 0.8;
      animation: hintPulse 3s ease-in-out infinite;
    }

    @media (max-width: 768px) {
      .title-letter { font-size: 50px; }
      .menu-option { font-size: 22px; }
      .gameover-title { font-size: 36px; }
      #score { font-size: 32px; }
    }
  </style>
</head>
<body>
<div id="game-wrapper">
  <canvas id="three-canvas"></canvas>
  <div id="crt-overlay"></div>
  <div id="vignette"></div>

  <div id="score">0 : 0</div>

  <!-- Start-Menü -->
  <div id="menu-overlay" class="overlay">
    <div class="title-row" id="cobie-title"></div>
    <div class="menu-option selected" data-mode="0"><span>Player vs CPU</span></div>
    <div class="menu-option" data-mode="1"><span>Player1 vs Player2</span></div>
    <div class="hint-text"><span>Press ENTER To Play</span></div>
  </div>

  <!-- Game Over -->
  <div id="gameover-overlay" class="overlay hidden">
    <div class="gameover-title" id="gameover-title">Player 1 Won!</div>
    <div class="gameover-sub" id="gameover-sub">Great job!</div>
    <div class="gameover-hint">Press ENTER to go back to menu</div>
  </div>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

  // ---------- Titel "CobiePong" bunt + wippend ----------
  const cobieTitle = document.getElementById("cobie-title");
  const cobieText = "CobiePong";
  const colorPalette = ["#4285F4", "#EA4335", "#FBBC05", "#34A853", "#A142F4"];

  for (let i = 0; i < cobieText.length; i++) {
    const span = document.createElement("span");
    span.className = "title-letter";
    span.textContent = cobieText[i];
    span.style.color = colorPalette[i % colorPalette.length];
    cobieTitle.appendChild(span);
  }

  // ---------- Game State ----------
  let gameState = "menu"; // "menu" | "playing" | "gameover"
  let gameMode = 0;       // 0 = PvCPU, 1 = PvP
  let menuIndex = 0;
  const WIN_SCORE = 5;

  const menuOverlay = document.getElementById("menu-overlay");
  const gameoverOverlay = document.getElementById("gameover-overlay");
  const gameoverTitle = document.getElementById("gameover-title");
  const gameoverSub = document.getElementById("gameover-sub");
  const scoreDisplay = document.getElementById("score");
  const menuOptions = Array.from(document.querySelectorAll(".menu-option"));

  function updateMenuVisual() {
    menuOptions.forEach((opt, i) => {
      opt.classList.toggle("selected", i === menuIndex);
    });
  }

  // ---------- Three.js Setup ----------
  const canvas = document.getElementById("three-canvas");
  const renderer = new THREE.WebGLRenderer({ 
    canvas, 
    antialias: true,
    powerPreference: "high-performance"
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  renderer.outputEncoding = THREE.sRGBEncoding;

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x050509, 15, 30);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 8, 16);
  camera.lookAt(0, 0, 0);

  // Postprocessing: Bloom
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.2,  // strength erhöht
    0.6,  // radius erhöht
    0.4   // threshold
  );
  composer.addPass(bloomPass);

  // Licht
  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);
  
  const spot1 = new THREE.SpotLight(0x52c7ff, 1.5, 60, Math.PI / 4, 0.4, 1.5);
  spot1.position.set(-8, 16, 0);
  spot1.target.position.set(-4, 0, 0);
  scene.add(spot1);
  scene.add(spot1.target);
  
  const spot2 = new THREE.SpotLight(0xff52a9, 1.5, 60, Math.PI / 4, 0.4, 1.5);
  spot2.position.set(8, 16, 0);
  spot2.target.position.set(4, 0, 0);
  scene.add(spot2);
  scene.add(spot2.target);

  // Hintergrund-Sternenfeld
  const starGeometry = new THREE.BufferGeometry();
  const starCount = 2000;
  const starPositions = new Float32Array(starCount * 3);
  
  for (let i = 0; i < starCount * 3; i += 3) {
    starPositions[i] = (Math.random() - 0.5) * 100;
    starPositions[i + 1] = (Math.random() - 0.5) * 50;
    starPositions[i + 2] = (Math.random() - 0.5) * 100 - 20;
  }
  
  starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
  
  const starMaterial = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.15,
    transparent: true,
    opacity: 0.8
  });
  
  const stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);

  // Dynamischer Nebel-Hintergrund
  const createNebula = () => {
    const nebulaGeometry = new THREE.BufferGeometry();
    const nebulaCount = 100;
    const nebulaPositions = new Float32Array(nebulaCount * 3);
    const nebulaColors = new Float32Array(nebulaCount * 3);
    const nebulaSizes = new Float32Array(nebulaCount);
    
    for (let i = 0; i < nebulaCount; i++) {
      const i3 = i * 3;
      nebulaPositions[i3] = (Math.random() - 0.5) * 80;
      nebulaPositions[i3 + 1] = (Math.random() - 0.5) * 40;
      nebulaPositions[i3 + 2] = (Math.random() - 0.5) * 80 - 30;
      
      const color = new THREE.Color();
      color.setHSL(Math.random() * 0.2 + 0.5, 0.7, Math.random() * 0.3 + 0.3);
      nebulaColors[i3] = color.r;
      nebulaColors[i3 + 1] = color.g;
      nebulaColors[i3 + 2] = color.b;
      
      nebulaSizes[i] = Math.random() * 10 + 5;
    }
    
    nebulaGeometry.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
    nebulaGeometry.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));
    nebulaGeometry.setAttribute('size', new THREE.BufferAttribute(nebulaSizes, 1));
    
    const nebulaMaterial = new THREE.PointsMaterial({
      size: 1,
      vertexColors: true,
      transparent: true,
      opacity: 0.4,
      blending: THREE.AdditiveBlending
    });
    
    return new THREE.Points(nebulaGeometry, nebulaMaterial);
  };
  
  const nebula = createNebula();
  scene.add(nebula);

  // Spielfeld
  const FIELD_WIDTH = 16;
  const FIELD_HEIGHT = 9;

  const fieldGeom = new THREE.PlaneGeometry(FIELD_WIDTH, FIELD_HEIGHT);
  const fieldMat = new THREE.MeshStandardMaterial({
    color: 0x10131f,
    metalness: 0.6,
    roughness: 0.3,
    emissive: 0x050810,
    emissiveIntensity: 0.2
  });
  const field = new THREE.Mesh(fieldGeom, fieldMat);
  field.rotation.x = -Math.PI / 2;
  scene.add(field);

  // Mittellinie
  const midLineGeom = new THREE.PlaneGeometry(0.08, FIELD_HEIGHT);
  const midLineMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    opacity: 0.4,
    transparent: true
  });
  const midLine = new THREE.Mesh(midLineGeom, midLineMat);
  midLine.position.set(0, 0.01, 0);
  midLine.rotation.x = -Math.PI / 2;
  scene.add(midLine);

  // Walls mit stärkerem Glow
  const wallMat = new THREE.MeshStandardMaterial({
    color: 0x293c7a,
    emissive: 0x112266,
    emissiveIntensity: 0.9,
    metalness: 0.8,
    roughness: 0.2
  });
  const wallThickness = 0.3;
  const wallHeight = 0.5;
  const wallGeomH = new THREE.BoxGeometry(FIELD_WIDTH, wallHeight, wallThickness);
  const wallGeomV = new THREE.BoxGeometry(wallThickness, wallHeight, FIELD_HEIGHT);

  const wallTop = new THREE.Mesh(wallGeomH, wallMat);
  wallTop.position.set(0, wallHeight/2, -FIELD_HEIGHT/2);
  const wallBottom = wallTop.clone();
  wallBottom.position.set(0, wallHeight/2, FIELD_HEIGHT/2);

  const wallLeft = new THREE.Mesh(wallGeomV, wallMat);
  wallLeft.position.set(-FIELD_WIDTH/2, wallHeight/2, 0);
  const wallRight = wallLeft.clone();
  wallRight.position.set(FIELD_WIDTH/2, wallHeight/2, 0);

  scene.add(wallTop, wallBottom, wallLeft, wallRight);

  // Paddles
  const paddleWidth = 0.4;
  const paddleHeight = 2.0;
  const paddleDepth = 0.4;

  const paddleGeom = new THREE.BoxGeometry(paddleWidth, paddleDepth, paddleHeight);
  const paddleMat1 = new THREE.MeshStandardMaterial({
    color: 0x52c7ff,
    emissive: 0x115577,
    emissiveIntensity: 1.5,
    metalness: 0.8,
    roughness: 0.2
  });
  const paddleMat2 = new THREE.MeshStandardMaterial({
    color: 0xff52a9,
    emissive: 0x771144,
    emissiveIntensity: 1.5,
    metalness: 0.8,
    roughness: 0.2
  });

  const paddle1Mesh = new THREE.Mesh(paddleGeom, paddleMat1);
  const paddle2Mesh = new THREE.Mesh(paddleGeom, paddleMat2);

  paddle1Mesh.position.set(-FIELD_WIDTH/2 + 1.0, paddleDepth/2, 0);
  paddle2Mesh.position.set(FIELD_WIDTH/2 - 1.0, paddleDepth/2, 0);

  scene.add(paddle1Mesh, paddle2Mesh);

  // Ball mit Glow
  const ballRadius = 0.25;
  const ballGeom = new THREE.SphereGeometry(ballRadius, 32, 32);
  const ballMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    emissive: 0x44aaff,
    emissiveIntensity: 2.5,
    metalness: 0.8,
    roughness: 0.1
  });
  const ballMesh = new THREE.Mesh(ballGeom, ballMat);
  ballMesh.position.set(0, ballRadius + 0.1, 0);
  scene.add(ballMesh);

  // Ball-Trail: mehrere kleine Kugeln mit Farbverlauf
  const trailCount = 20;
  const trailMeshes = [];
  const trailColors = [
    new THREE.Color(0x52c7ff),
    new THREE.Color(0x44aaff),
    new THREE.Color(0x3688ff),
    new THREE.Color(0x2866ff)
  ];
  
  for (let i = 0; i < trailCount; i++) {
    const tGeom = new THREE.SphereGeometry(ballRadius * 0.9, 16, 16);
    const colorIndex = Math.floor(i / (trailCount / trailColors.length));
    const tMat = new THREE.MeshBasicMaterial({
      color: trailColors[colorIndex],
      transparent: true,
      opacity: 0.0
    });
    const tMesh = new THREE.Mesh(tGeom, tMat);
    tMesh.visible = true;
    scene.add(tMesh);
    trailMeshes.push(tMesh);
  }
  let trailIndex = 0;

  function updateBallTrail() {
    const current = trailMeshes[trailIndex];
    current.position.copy(ballMesh.position);
    current.material.opacity = 0.8;
    current.scale.set(1, 1, 1);

    trailIndex = (trailIndex + 1) % trailCount;

    for (let i = 0; i < trailCount; i++) {
      if (i !== trailIndex) {
        const m = trailMeshes[i];
        m.material.opacity *= 0.82;
        m.scale.multiplyScalar(0.94);
      }
    }
  }

  // Verbesserte Neon-Explosionen (Partikel) bei Wandkontakt
  const explosions = [];
  function spawnWallExplosion(x, z, color1 = 0x44ccff, color2 = 0xff44aa) {
    const count = 30;
    for (let i = 0; i < count; i++) {
      const g = new THREE.SphereGeometry(0.12, 8, 8);
      const m = new THREE.MeshBasicMaterial({
        color: (i % 2 === 0) ? color1 : color2,
        transparent: true,
        opacity: 1.0
      });
      const mesh = new THREE.Mesh(g, m);
      mesh.position.set(x, ballRadius + 0.15, z);
      scene.add(mesh);

      const angle = Math.random() * Math.PI * 2;
      const speed = 0.1 + Math.random() * 0.15;
      const vy = 0.03 + Math.random() * 0.06;
      explosions.push({
        mesh,
        vx: Math.cos(angle) * speed,
        vz: Math.sin(angle) * speed,
        vy,
        life: 0.7 + Math.random() * 0.5
      });
    }
  }

  // Explosionen für Paddle-Treffer
  function spawnPaddleExplosion(x, z, isLeftPaddle) {
    const color1 = isLeftPaddle ? 0x52c7ff : 0xff52a9;
    const color2 = isLeftPaddle ? 0x44aaff : 0xff44aa;
    spawnWallExplosion(x, z, color1, color2);
  }

  function updateExplosions(dt) {
    for (let i = explosions.length - 1; i >= 0; i--) {
      const e = explosions[i];
      e.life -= dt;
      if (e.life <= 0) {
        scene.remove(e.mesh);
        explosions.splice(i, 1);
        continue;
      }
      e.mesh.position.x += e.vx;
      e.mesh.position.z += e.vz;
      e.mesh.position.y += e.vy;
      e.vy -= 0.005;
      e.mesh.material.opacity = Math.max(0, e.life * 1.5);
      e.mesh.scale.multiplyScalar(0.97);
    }
  }

  // Hintergrund-Deko: Neon-Ringe
  const ringGeom = new THREE.TorusGeometry(FIELD_WIDTH/2.2, 0.03, 16, 100);
  const ringMat = new THREE.MeshBasicMaterial({ 
    color: 0x333366,
    transparent: true,
    opacity: 0.7
  });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI/2;
  ring.position.y = 0.02;
  scene.add(ring);

  const ring2Geom = new THREE.TorusGeometry(FIELD_WIDTH/3, 0.02, 16, 100);
  const ring2Mat = new THREE.MeshBasicMaterial({ 
    color: 0x223344,
    transparent: true,
    opacity: 0.5
  });
  const ring2 = new THREE.Mesh(ring2Geom, ring2Mat);
  ring2.rotation.x = Math.PI/2;
  ring2.position.y = 0.03;
  scene.add(ring2);

  // ---------- Spiel-Logik (X/Z) ----------

  let keys = {};
  let p1 = { z: 0 };
  let p2 = { z: 0 };

  const BALL_BASE_SPEED = 0.16;
  let ball = { x: 0, z: 0, vx: BALL_BASE_SPEED, vz: 0.0 };
  let hitCount = 0;
  let score = { p1: 0, p2: 0 };
  let cameraShake = 0;

  function calculateSpeedMultiplier(hitCount) {
    if (hitCount <= 5) {
      return 1 + hitCount * 0.2; // bis +100%
    }
    if (hitCount < 10) {
      return 2.0; // +100%
    }
    return 3.0; // +200%
  }

  function resetBall(direction = 1) {
    ball.x = 0;
    ball.z = 0;
    hitCount = 0;

    const maxAngle = Math.PI / 4; // ±45°
    const angle = (Math.random() * 2 - 1) * maxAngle;
    const dirX = direction >= 0 ? 1 : -1;
    ball.vx = Math.cos(angle) * BALL_BASE_SPEED * dirX;
    ball.vz = Math.sin(angle) * BALL_BASE_SPEED;
  }

  function resetGameToMenu() {
    score.p1 = 0;
    score.p2 = 0;
    scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
    p1.z = 0;
    p2.z = 0;
    resetBall(1);
    gameState = "menu";
    menuOverlay.classList.remove("hidden");
    gameoverOverlay.classList.add("hidden");
  }

  resetBall(1);

  // Eingaben
  document.addEventListener("keydown", (e) => {
    keys[e.key] = true;

    if (gameState === "menu") {
      if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        menuIndex = menuIndex === 0 ? 1 : 0;
        updateMenuVisual();
      }
      if (e.key === "Enter") {
        gameMode = menuIndex;
        menuOverlay.classList.add("hidden");
        gameoverOverlay.classList.add("hidden");
        gameState = "playing";
        resetBall(1);
      }
    } else if (gameState === "gameover") {
      if (e.key === "Enter") {
        resetGameToMenu();
      }
    }
  });

  document.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  function variablePaddleBounce(isLeftPaddle) {
    const paddleZ = isLeftPaddle ? p1.z : p2.z;
    const rel = (ball.z - paddleZ) / (paddleHeight / 2);
    const clamped = Math.max(-1, Math.min(1, rel));
    const maxAngle = Math.PI / 3; // bis 60°
    const angle = clamped * maxAngle;

    const dirX = isLeftPaddle ? 1 : -1;
    ball.vx = Math.cos(angle) * BALL_BASE_SPEED * dirX;
    ball.vz = Math.sin(angle) * BALL_BASE_SPEED;
    
    // Screen-Shake bei starken Treffern
    cameraShake = 0.3;
    
    // Explosion beim Paddle-Treffer
    spawnPaddleExplosion(ball.x, ball.z, isLeftPaddle);
  }

  function updateGame(dt) {
    const paddleSpeed = 0.22;

    // Player 1
    if (keys["w"]) p1.z -= paddleSpeed;
    if (keys["s"]) p1.z += paddleSpeed;

    const maxZ = FIELD_HEIGHT/2 - paddleHeight/2;
    p1.z = Math.max(-maxZ, Math.min(maxZ, p1.z));

    // Player 2 / CPU
    if (gameMode === 1) {
      if (keys["ArrowUp"]) p2.z -= paddleSpeed;
      if (keys["ArrowDown"]) p2.z += paddleSpeed;
      p2.z = Math.max(-maxZ, Math.min(maxZ, p2.z));
    } else {
      const cpuSpeed = 0.18;
      if (ball.z < p2.z - 0.2) p2.z -= cpuSpeed;
      if (ball.z > p2.z + 0.2) p2.z += cpuSpeed;
      p2.z = Math.max(-maxZ, Math.min(maxZ, p2.z));
    }

    // Ballbewegung
    const speedMult = calculateSpeedMultiplier(hitCount);
    ball.x += ball.vx * speedMult;
    ball.z += ball.vz * speedMult;

    // Wandkollision (oben/unten) = Explosion
    const topZ = -FIELD_HEIGHT/2 + ballRadius;
    const bottomZ = FIELD_HEIGHT/2 - ballRadius;
    if (ball.z < topZ) {
      ball.z = topZ;
      spawnWallExplosion(ball.x, topZ);
      ball.vz *= -1;
      cameraShake = 0.2;
    } else if (ball.z > bottomZ) {
      ball.z = bottomZ;
      spawnWallExplosion(ball.x, bottomZ);
      ball.vz *= -1;
      cameraShake = 0.2;
    }

    // Paddle-Kollision
    const p1X = -FIELD_WIDTH/2 + 1.0;
    const p2X = FIELD_WIDTH/2 - 1.0;

    function checkPaddleCollision(px, pz) {
      const paddleHalfH = paddleHeight/2;
      const paddleHalfW = paddleWidth/2 + ballRadius;
      const withinZ = ball.z > (pz - paddleHalfH) && ball.z < (pz + paddleHalfH);
      const closeX = Math.abs(ball.x - px) < paddleHalfW;
      return withinZ && closeX;
    }

    if (checkPaddleCollision(p1X, p1.z) && ball.vx < 0) {
      variablePaddleBounce(true);
      hitCount++;
    }

    if (checkPaddleCollision(p2X, p2.z) && ball.vx > 0) {
      variablePaddleBounce(false);
      hitCount++;
    }

    // Punkte
    if (ball.x < -FIELD_WIDTH/2 - 1) {
      score.p2++;
      scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
      checkWinOrContinue(-1);
    } else if (ball.x > FIELD_WIDTH/2 + 1) {
      score.p1++;
      scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
      checkWinOrContinue(1);
    }

    // Meshes updaten
    paddle1Mesh.position.z = p1.z;
    paddle2Mesh.position.z = p2.z;
    ballMesh.position.set(ball.x, ballRadius + 0.1, ball.z);

    // Ball-Trail & Explosionen
    updateBallTrail();
    updateExplosions(dt);
    
    // Screen-Shake
    if (cameraShake > 0) {
      camera.position.x = (Math.random() - 0.5) * cameraShake;
      camera.position.y = 8 + (Math.random() - 0.5) * cameraShake;
      cameraShake -= dt * 2;
    } else {
      camera.position.x = 0;
      camera.position.y = 8;
    }
    camera.lookAt(0, 0, 0);
  }

  function checkWinOrContinue(lastDirection) {
    if (score.p1 >= WIN_SCORE || score.p2 >= WIN_SCORE) {
      gameState = "gameover";
      let msg = "";
      let sub = "";
      if (score.p1 > score.p2) {
        msg = "Player 1 Won!";
        sub = "Nice reflexes!";
      } else {
        if (gameMode === 0) {
          msg = "You loose against an CPU!";
          sub = "Try Harder!";
        } else {
          msg = "Player 2 Won!";
          sub = "Well played!";
        }
      }
      gameoverTitle.textContent = msg;
      gameoverSub.textContent = sub;
      gameoverOverlay.classList.remove("hidden");
    } else {
      resetBall(-lastDirection);
    }
  }

  // ---------- Animation Loop ----------
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const t = clock.getElapsedTime();

    // VFX: Walls & Midline pulsieren
    const pulse = 0.6 + 0.4 * Math.sin(t * 2.0);
    wallMat.emissiveIntensity = 0.7 + 0.5 * pulse;
    midLineMat.opacity = 0.3 + 0.3 * (0.5 + 0.5 * Math.sin(t * 3.0));
    
    // Ball-Material Pulsieren
    ballMat.emissiveIntensity = 2.0 + 0.5 * Math.sin(t * 5.0);
    
    // Paddle-Material Pulsieren
    paddleMat1.emissiveIntensity = 1.2 + 0.3 * Math.sin(t * 3.0);
    paddleMat2.emissiveIntensity = 1.2 + 0.3 * Math.sin(t * 3.5);

    // Ringe rotieren
    ring.rotation.y += 0.002;
    ring2.rotation.y -= 0.0015;
    
    // Sterne bewegen sich leicht
    stars.rotation.y += 0.0001;
    
    // Nebula bewegt sich
    nebula.rotation.y += 0.00005;
    nebula.rotation.x += 0.00003;

    if (gameState === "playing") {
      updateGame(dt);
    }

    composer.render();
  }

  animate();

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
