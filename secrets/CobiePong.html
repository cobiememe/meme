<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>CobiePong - Neon Wallet Edition</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #050509;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
    }

    #game-wrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
    }

    canvas#three-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Score oben zentriert */
    #score {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 42px;
      font-weight: 900;
      pointer-events: none;
      z-index: 5;
      letter-spacing: 4px;
      background: linear-gradient(90deg, #ff5252, #ffd452, #4dff4d, #52c7ff, #d452ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 15px rgba(100, 200, 255, 0.9);
      animation: scorePulse 2s ease-in-out infinite alternate;
    }

    @keyframes scorePulse {
      0% { transform: translateX(-50%) scale(1); }
      100% { transform: translateX(-50%) scale(1.05); }
    }

    /* Wallet Button + Label (oben rechts) */
    .wallet-btn {
      position: absolute;
      top: 20px;
      right: 30px;
      z-index: 20;
      padding: 10px 18px;
      background: transparent;
      border: 2px solid #00ffa3;
      color: #00ffa3;
      font-weight: 700;
      border-radius: 12px;
      cursor: pointer;
      text-shadow: 0 0 12px #00ffa3;
      transition: 0.25s;
    }

    .wallet-btn:hover {
      background: #00ffa3;
      color: #000;
      box-shadow: 0 0 20px #00ffa3;
    }

    .wallet-label {
      position: absolute;
      top: 70px;
      right: 32px;
      z-index: 20;
      font-size: 14px;
      color: #aaffee;
      text-shadow: 0 0 8px #00ffa3;
    }

    /* CRT / Scanline Overlay */
    #crt-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: overlay;
      opacity: 0.3;
      z-index: 4;
      background-image:
        repeating-linear-gradient(
          to bottom,
          rgba(0,0,0,0.65),
          rgba(0,0,0,0.65) 1px,
          rgba(0,0,0,0.0) 3px
        ),
        radial-gradient(circle at center, rgba(255,255,255,0.12), rgba(0,0,0,0.95));
    }

    /* Vignette-Effekt */
    #vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 3;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 60%, rgba(0,0,0,0.7) 100%);
    }

    /* Shared Overlay-Styling (Menu & Game Over) */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at center, rgba(0, 30, 60, 0.8) 0%, rgba(0, 0, 0, 0.96) 70%);
      z-index: 10;
      backdrop-filter: blur(5px);
    }

    .hidden {
      display: none;
    }

    /* CobiePong Titel */
    .title-row {
      display: flex;
      gap: 4px;
      margin-bottom: 28px;
      perspective: 800px;
    }

    .title-letter {
      font-size: 72px;
      font-weight: 900;
      display: inline-block;
      animation: bob 1.2s ease-in-out infinite;
      transform-origin: center bottom;
      text-shadow: 0 0 20px currentColor;
      filter: drop-shadow(0 0 8px rgba(255,255,255,0.6));
    }

    .title-letter:nth-child(1) { animation-delay: 0s; }
    .title-letter:nth-child(2) { animation-delay: 0.08s; }
    .title-letter:nth-child(3) { animation-delay: 0.16s; }
    .title-letter:nth-child(4) { animation-delay: 0.24s; }
    .title-letter:nth-child(5) { animation-delay: 0.32s; }
    .title-letter:nth-child(6) { animation-delay: 0.40s; }
    .title-letter:nth-child(7) { animation-delay: 0.48s; }
    .title-letter:nth-child(8) { animation-delay: 0.56s; }
    .title-letter:nth-child(9) { animation-delay: 0.64s; }

    @keyframes bob {
      0%,100% { transform: translateY(0) rotateX(0deg); }
      50% { transform: translateY(-12px) rotateX(8deg); }
    }

    .menu-option {
      font-size: 28px;
      margin: 10px 0;
      padding: 8px 24px;
      border-radius: 999px;
      cursor: pointer;
      background: rgba(0,0,0,0.6);
      border: 2px solid rgba(255,255,255,0.18);
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .menu-option::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.25), transparent);
      transition: left 0.5s;
    }

    .menu-option:hover::before {
      left: 100%;
    }

    .menu-option span {
      background: linear-gradient(90deg, #ff5252, #ffd452, #4dff4d, #52c7ff, #d452ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-weight: 600;
    }

    .menu-option.selected {
      transform: translateY(-4px) scale(1.05);
      box-shadow: 0 0 25px rgba(255,255,255,0.3);
      background: rgba(255,255,255,0.08);
      border-color: rgba(255,255,255,0.4);
    }

    .hint-text {
      margin-top: 30px;
      font-size: 20px;
      letter-spacing: 1px;
      text-shadow: 0 0 8px rgba(0,0,0,0.9);
      animation: hintPulse 2.2s ease-in-out infinite;
    }

    .hint-text span {
      background: linear-gradient(90deg, #ffd452, #ff5252, #d452ff, #52c7ff, #4dff4d);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    @keyframes hintPulse {
      0%,100% { opacity: 0.7; }
      50% { opacity: 1; }
    }

    /* Game Over Text */
    .gameover-title {
      font-size: 52px;
      font-weight: 800;
      margin-bottom: 20px;
      text-align: center;
      text-shadow: 0 0 20px rgba(0,0,0,0.9);
      background: linear-gradient(90deg, #ff5252, #ffd452, #4dff4d, #52c7ff, #d452ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      animation: gameoverPulse 2s ease-in-out infinite alternate;
    }

    @keyframes gameoverPulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.05); }
    }

    .gameover-sub {
      font-size: 24px;
      opacity: 0.95;
      margin-bottom: 40px;
      text-align: center;
      color: #ffffff;
      text-shadow: 0 0 10px rgba(0,0,0,0.9);
    }

    .gameover-hint {
      font-size: 20px;
      opacity: 0.85;
      animation: hintPulse 3s ease-in-out infinite;
    }

    @media (max-width: 768px) {
      .title-letter { font-size: 50px; }
      .menu-option { font-size: 22px; }
      .gameover-title { font-size: 36px; }
      #score { font-size: 32px; }
    }
  </style>
</head>
<body>
<div id="game-wrapper">
  <canvas id="three-canvas"></canvas>
  <div id="crt-overlay"></div>
  <div id="vignette"></div>

  <div id="score">0 : 0</div>

  <!-- Wallet UI oben rechts -->
  <button id="connectWalletBtn" class="wallet-btn">Connect Wallet</button>
  <div id="walletLabel" class="wallet-label">Not connected</div>

  <!-- Start-Menü -->
  <div id="menu-overlay" class="overlay">
    <div class="title-row" id="cobie-title"></div>
    <div class="menu-option selected" data-mode="0"><span>Player vs CPU</span></div>
    <div class="menu-option" data-mode="1"><span>Player1 vs Player2</span></div>
    <div class="hint-text"><span>Press ENTER To Play</span></div>
  </div>

  <!-- Game Over -->
  <div id="gameover-overlay" class="overlay hidden">
    <div class="gameover-title" id="gameover-title">Player 1 Won!</div>
    <div class="gameover-sub" id="gameover-sub">Nice!</div>
    <div class="gameover-hint">Press ENTER to go back to menu</div>
  </div>
</div>

<!-- Phantom / Solana Wallet Script -->
<script type="module">
import { Connection, PublicKey } from "https://esm.sh/@solana/web3.js@1.87.6";

/* --------------------------------------------------------
   SOLANA PHANTOM CONNECTION
   -------------------------------------------------------- */

const MAINNET = true;
const HELIUS_KEY = "b5dce25c-09db-45bd-ba9b-d2e2f16fc841";

const RPC = MAINNET
  ? `https://mainnet.helius-rpc.com/?api-key=${HELIUS_KEY}`
  : "https://api.devnet.solana.com";

const connectBtn = document.getElementById("connectWalletBtn");
const walletLabel = document.getElementById("walletLabel");

function getProvider() {
  if ("phantom" in window) {
    const provider = window.phantom?.solana;
    if (provider?.isPhantom) return provider;
  }
  return null;
}

function setConnected(pubkey) {
  walletLabel.textContent = "Connected: " + pubkey.slice(0,4) + "..." + pubkey.slice(-4);
  connectBtn.textContent = "Disconnect";
}

function setDisconnected() {
  walletLabel.textContent = "Not connected";
  connectBtn.textContent = "Connect Wallet";
}

/* ---------------------- CONNECT ---------------------- */

async function connectWallet() {
  const provider = getProvider();
  if (!provider) {
    alert("⚠️ Phantom Wallet nicht gefunden!");
    window.open("https://phantom.app", "_blank");
    return;
  }

  try {
    const { publicKey } = await provider.connect({ onlyIfTrusted: false });
    setConnected(publicKey.toString());
    window.PLAYER_PUBLICKEY = publicKey.toString();

    if (!provider.__pongBound) {
      provider.on("disconnect", () => {
        setDisconnected();
        window.PLAYER_PUBLICKEY = null;
      });
      provider.__pongBound = true;
    }

  } catch (err) {
    console.log("Wallet connection failed:", err);
    setDisconnected();
  }
}

/* ---------------------- DISCONNECT ---------------------- */

async function disconnectWallet() {
  const provider = getProvider();
  if (!provider) return;

  try {
    await provider.disconnect();
  } catch (e) {}

  setDisconnected();
  window.PLAYER_PUBLICKEY = null;
}

connectBtn.addEventListener("click", () => {
  const provider = getProvider();
  if (!provider) return connectWallet();

  if (provider.isConnected) disconnectWallet();
  else connectWallet();
});

/* Auto-check connection on load */
window.addEventListener("load", () => {
  const provider = getProvider();
  if (provider?.isConnected) {
    setConnected(provider.publicKey.toString());
    window.PLAYER_PUBLICKEY = provider.publicKey.toString();
  } else {
    setDisconnected();
  }
});
</script>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
  // ---------- Titel "CobiePong" bunt + wippend ----------
  const cobieTitle = document.getElementById("cobie-title");
  const cobieText = "CobiePong";
  const colorPalette = ["#4285F4", "#EA4335", "#FBBC05", "#34A853", "#A142F4"];

  for (let i = 0; i < cobieText.length; i++) {
    const span = document.createElement("span");
    span.className = "title-letter";
    span.textContent = cobieText[i];
    span.style.color = colorPalette[i % colorPalette.length];
    cobieTitle.appendChild(span);
  }

  // ---------- Game State ----------
  let gameState = "menu"; // "menu" | "playing" | "gameover"
  let gameMode = 0;       // 0 = PvCPU, 1 = PvP
  let menuIndex = 0;
  const WIN_SCORE = 5;

  const menuOverlay = document.getElementById("menu-overlay");
  const gameoverOverlay = document.getElementById("gameover-overlay");
  const gameoverTitle = document.getElementById("gameover-title");
  const gameoverSub   = document.getElementById("gameover-sub");
  const scoreDisplay  = document.getElementById("score");
  const menuOptions   = Array.from(document.querySelectorAll(".menu-option"));

  function updateMenuVisual() {
    menuOptions.forEach((opt, i) => {
      opt.classList.toggle("selected", i === menuIndex);
    });
  }
  updateMenuVisual();

  // ---------- Sounds ----------
  const sndBounce = new Audio("../sounds/power1.wav");
  sndBounce.volume = 0.4;

  function playBounce() {
    try {
      sndBounce.currentTime = 0;
      sndBounce.play();
    } catch (e) {}
  }

  // ---------- Three.js Setup ----------
  const canvas = document.getElementById("three-canvas");
  const renderer = new THREE.WebGLRenderer({
    canvas,
    antialias: true,
    powerPreference: "high-performance"
  });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.2;
  renderer.outputEncoding = THREE.sRGBEncoding;

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x050509, 15, 30);

  const camera = new THREE.PerspectiveCamera(
    50,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(0, 8, 16);
  camera.lookAt(0, 0, 0);

  const ambient = new THREE.AmbientLight(0xffffff, 0.4);
  scene.add(ambient);

  const spot1 = new THREE.SpotLight(0x52c7ff, 1.5, 60, Math.PI / 4, 0.4, 1.5);
  spot1.position.set(-8, 16, 0);
  spot1.target.position.set(-4, 0, 0);
  scene.add(spot1, spot1.target);

  const spot2 = new THREE.SpotLight(0xff52a9, 1.5, 60, Math.PI / 4, 0.4, 1.5);
  spot2.position.set(8, 16, 0);
  spot2.target.position.set(4, 0, 0);
  scene.add(spot2, spot2.target);

  // ---------- Neon Sternfeld ----------
  const starCount = 1500;
  const starGeom = new THREE.BufferGeometry();
  const starPositions = new Float32Array(starCount * 3);
  const starColors = new Float32Array(starCount * 3);

  for (let i = 0; i < starCount; i++) {
    const i3 = i * 3;
    starPositions[i3]   = (Math.random() - 0.5) * 120;
    starPositions[i3+1] = (Math.random() - 0.5) * 60;
    starPositions[i3+2] = (Math.random() - 0.5) * 120;

    const palette = [
      new THREE.Color(0x52c7ff),
      new THREE.Color(0xd452ff),
      new THREE.Color(0x4dffb8),
      new THREE.Color(0xffffff)
    ];
    const c = palette[Math.floor(Math.random() * palette.length)];
    starColors[i3]   = c.r;
    starColors[i3+1] = c.g;
    starColors[i3+2] = c.b;
  }

  starGeom.setAttribute("position", new THREE.BufferAttribute(starPositions, 3));
  starGeom.setAttribute("color", new THREE.BufferAttribute(starColors, 3));

  const starMat = new THREE.PointsMaterial({
    size: 0.16,
    vertexColors: true,
    transparent: true,
    opacity: 0.9,
    depthWrite: false
  });

  const stars = new THREE.Points(starGeom, starMat);
  scene.add(stars);

  // ---------- Spielfeld ----------
  const FIELD_WIDTH = 16;
  const FIELD_HEIGHT = 9;

  const fieldGeom = new THREE.PlaneGeometry(FIELD_WIDTH, FIELD_HEIGHT);
  const fieldMat = new THREE.MeshStandardMaterial({
    color: 0x10131f,
    metalness: 0.7,
    roughness: 0.28,
    emissive: 0x050810,
    emissiveIntensity: 0.25
  });
  const field = new THREE.Mesh(fieldGeom, fieldMat);
  field.rotation.x = -Math.PI / 2;
  scene.add(field);

  const midLineGeom = new THREE.PlaneGeometry(0.08, FIELD_HEIGHT);
  const midLineMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    opacity: 0.4,
    transparent: true
  });
  const midLine = new THREE.Mesh(midLineGeom, midLineMat);
  midLine.position.set(0, 0.01, 0);
  midLine.rotation.x = -Math.PI / 2;
  scene.add(midLine);

  // Walls
  const wallMat = new THREE.MeshStandardMaterial({
    color: 0x293c7a,
    emissive: 0x112266,
    emissiveIntensity: 1.1,
    metalness: 0.8,
    roughness: 0.22
  });
  const wallThickness = 0.3;
  const wallHeight = 0.5;
  const wallGeomH = new THREE.BoxGeometry(FIELD_WIDTH, wallHeight, wallThickness);
  const wallGeomV = new THREE.BoxGeometry(wallThickness, wallHeight, FIELD_HEIGHT);

  const wallTop = new THREE.Mesh(wallGeomH, wallMat);
  wallTop.position.set(0, wallHeight / 2, -FIELD_HEIGHT / 2);
  const wallBottom = wallTop.clone();
  wallBottom.position.set(0, wallHeight / 2, FIELD_HEIGHT / 2);
  const wallLeft = new THREE.Mesh(wallGeomV, wallMat);
  wallLeft.position.set(-FIELD_WIDTH / 2, wallHeight / 2, 0);
  const wallRight = wallLeft.clone();
  wallRight.position.set(FIELD_WIDTH / 2, wallHeight / 2, 0);

  scene.add(wallTop, wallBottom, wallLeft, wallRight);

  // ---------- Paddles ----------
  const paddleWidth = 0.4;
  const paddleHeight = 2.0;
  const paddleDepth = 0.4;

  const paddleGeom = new THREE.BoxGeometry(paddleWidth, paddleDepth, paddleHeight);
  const paddleMat1 = new THREE.MeshStandardMaterial({
    color: 0x52c7ff,
    emissive: 0x115577,
    emissiveIntensity: 1.4,
    metalness: 0.8,
    roughness: 0.2
  });
  const paddleMat2 = new THREE.MeshStandardMaterial({
    color: 0xff52a9,
    emissive: 0x771144,
    emissiveIntensity: 1.4,
    metalness: 0.8,
    roughness: 0.2
  });

  const paddle1Mesh = new THREE.Mesh(paddleGeom, paddleMat1);
  const paddle2Mesh = new THREE.Mesh(paddleGeom, paddleMat2);

  paddle1Mesh.position.set(-FIELD_WIDTH / 2 + 1, paddleDepth / 2, 0);
  paddle2Mesh.position.set( FIELD_WIDTH / 2 - 1, paddleDepth / 2, 0);

  scene.add(paddle1Mesh, paddle2Mesh);

  // ---------- Ball ----------
  const ballRadius = 0.25;
  const ballGeom = new THREE.SphereGeometry(ballRadius, 32, 32);
  const ballMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    emissive: 0x3388ff,
    emissiveIntensity: 2.2,
    metalness: 0.6,
    roughness: 0.35
  });
  const ballMesh = new THREE.Mesh(ballGeom, ballMat);
  ballMesh.position.set(0, ballRadius + 0.1, 0);
  scene.add(ballMesh);

  // ---------- Ball Trail ----------
  const trailCount = 22;
  const trail = [];
  let trailIndex = 0;
  const trailColors = [0x52c7ff, 0x44aaff, 0x3688ff, 0xd452ff];

  for (let i = 0; i < trailCount; i++) {
    const m = new THREE.Mesh(
      new THREE.SphereGeometry(ballRadius * 0.85, 16, 16),
      new THREE.MeshBasicMaterial({
        color: trailColors[Math.floor(i / (trailCount / 4))],
        transparent: true,
        opacity: 0
      })
    );
    scene.add(m);
    trail.push(m);
  }

  function updateBallTrail() {
    const tMesh = trail[trailIndex];
    tMesh.position.copy(ballMesh.position);
    tMesh.material.opacity = 0.9;
    tMesh.scale.set(1, 1, 1);

    trailIndex = (trailIndex + 1) % trailCount;
    for (let i = 0; i < trailCount; i++) {
      if (i === trailIndex) continue;
      const m = trail[i];
      m.material.opacity *= 0.83;
      m.scale.multiplyScalar(0.94);
    }
  }

  // ---------- Explosion Partikel ----------
  let explosions = [];

  function spawnWallExplosion(x, z, c1 = 0x55ccff, c2 = 0xff55aa) {
    for (let i = 0; i < 28; i++) {
      const g = new THREE.SphereGeometry(0.12, 8, 8);
      const col = (i % 2 === 0) ? c1 : c2;
      const m = new THREE.MeshBasicMaterial({
        color: col,
        transparent: true,
        opacity: 1
      });
      const mesh = new THREE.Mesh(g, m);
      mesh.position.set(x, ballRadius + 0.15, z);
      scene.add(mesh);

      const angle = Math.random() * Math.PI * 2;
      const speed = 0.25 + Math.random() * 0.4;
      const vy = 0.02 + Math.random() * 0.15;
      explosions.push({
        mesh,
        vx: Math.cos(angle) * speed,
        vz: Math.sin(angle) * speed,
        vy,
        life: 0.8 + Math.random() * 0.6
      });
    }
  }

  function spawnPaddleExplosion(x, z, isLeft) {
    const c1 = isLeft ? 0x52c7ff : 0xff52a9;
    const c2 = isLeft ? 0x44aaff : 0xff44aa;
    spawnWallExplosion(x, z, c1, c2);
  }

  function updateExplosions(dt) {
    for (let i = explosions.length - 1; i >= 0; i--) {
      const e = explosions[i];
      e.life -= dt;
      if (e.life <= 0) {
        scene.remove(e.mesh);
        explosions.splice(i, 1);
        continue;
      }
      e.mesh.position.x += e.vx;
      e.mesh.position.z += e.vz;
      e.mesh.position.y += e.vy;
      e.vy -= 0.005;
      e.mesh.material.opacity = Math.max(0, e.life * 1.5);
      e.mesh.scale.multiplyScalar(0.97);
    }
  }

  // Neon-Ringe
  const ringGeom = new THREE.TorusGeometry(FIELD_WIDTH / 2.2, 0.03, 16, 100);
  const ringMat = new THREE.MeshBasicMaterial({
    color: 0x333366,
    transparent: true,
    opacity: 0.7
  });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI / 2;
  ring.position.y = 0.02;
  scene.add(ring);

  const ring2Geom = new THREE.TorusGeometry(FIELD_WIDTH / 3, 0.03, 16, 100);
  const ring2Mat = new THREE.MeshBasicMaterial({
    color: 0x223344,
    transparent: true,
    opacity: 0.5
  });
  const ring2 = new THREE.Mesh(ring2Geom, ring2Mat);
  ring2.rotation.x = Math.PI / 2;
  ring2.position.y = 0.03;
  scene.add(ring2);

  // ---------- Gameplay ----------
  let keys = {};
  let p1 = { z: 0 };
  let p2 = { z: 0 };
  const BALL_BASE_SPEED = 0.16;
  let ball = { x: 0, z: 0, vx: BALL_BASE_SPEED, vz: 0 };
  let hitCount = 0;
  let score = { p1: 0, p2: 0 };
  let cameraShake = 0;

  function calculateSpeedMultiplier(hc) {
    if (hc <= 5) return 1 + hc * 0.2;
    if (hc < 10) return 2.0;
    return 3.0;
  }

  function resetBall(dir = 1) {
    ball.x = 0;
    ball.z = 0;
    hitCount = 0;
    const maxAngle = Math.PI / 4;
    const angle = (Math.random() * 2 - 1) * maxAngle;
    const dirX = dir >= 0 ? 1 : -1;
    ball.vx = Math.cos(angle) * BALL_BASE_SPEED * dirX;
    ball.vz = Math.sin(angle) * BALL_BASE_SPEED;
  }

  function resetGameToMenu() {
    score.p1 = 0;
    score.p2 = 0;
    scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
    p1.z = 0;
    p2.z = 0;
    resetBall(1);
    gameState = "menu";
    menuOverlay.classList.remove("hidden");
    gameoverOverlay.classList.add("hidden");
  }
  resetBall(1);

  // Eingaben
  document.addEventListener("keydown", (e) => {
    keys[e.key] = true;

    if (gameState === "menu") {
      if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        menuIndex = menuIndex === 0 ? 1 : 0;
        updateMenuVisual();
      }
      if (e.key === "Enter") {
        // ✅ Nur starten, wenn Wallet connected
        if (!window.PLAYER_PUBLICKEY) {
          alert("Please connect your Phantom Wallet first!");
          return;
        }
        gameMode = menuIndex;
        menuOverlay.classList.add("hidden");
        gameoverOverlay.classList.add("hidden");
        gameState = "playing";
        resetBall(1);
      }
    } else if (gameState === "gameover") {
      if (e.key === "Enter") {
        resetGameToMenu();
      }
    }
  });

  document.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  function variablePaddleBounce(isLeftPaddle) {
    const paddleZ = isLeftPaddle ? p1.z : p2.z;
    const rel = (ball.z - paddleZ) / (paddleHeight / 2);
    const clamped = Math.max(-1, Math.min(1, rel));
    const maxAngle = Math.PI / 3;
    const angle = clamped * maxAngle;
    const dirX = isLeftPaddle ? 1 : -1;
    ball.vx = Math.cos(angle) * BALL_BASE_SPEED * dirX;
    ball.vz = Math.sin(angle) * BALL_BASE_SPEED;

    hitCount++;
    cameraShake = 0.3;
    spawnPaddleExplosion(ball.x, ball.z, isLeftPaddle);
    playBounce();
  }

  function updateGame(dt) {
    const paddleSpeed = 0.22;

    // Player 1
    if (keys["w"]) p1.z -= paddleSpeed;
    if (keys["s"]) p1.z += paddleSpeed;

    const maxZ = FIELD_HEIGHT / 2 - paddleHeight / 2;
    p1.z = Math.max(-maxZ, Math.min(maxZ, p1.z));

    // Player 2 / CPU
    if (gameMode === 1) {
      if (keys["ArrowUp"]) p2.z -= paddleSpeed;
      if (keys["ArrowDown"]) p2.z += paddleSpeed;
      p2.z = Math.max(-maxZ, Math.min(maxZ, p2.z));
    } else {
      const cpuSpeed = 0.18;
      if (ball.z < p2.z - 0.2) p2.z -= cpuSpeed;
      if (ball.z > p2.z + 0.2) p2.z += cpuSpeed;
      p2.z = Math.max(-maxZ, Math.min(maxZ, p2.z));
    }

    // Ballbewegung
    const speedMult = calculateSpeedMultiplier(hitCount);
    ball.x += ball.vx * speedMult;
    ball.z += ball.vz * speedMult;

    // Wandkollision (oben/unten)
    const topZ = -FIELD_HEIGHT / 2 + ballRadius;
    const bottomZ = FIELD_HEIGHT / 2 - ballRadius;
    if (ball.z < topZ) {
      ball.z = topZ;
      spawnWallExplosion(ball.x, topZ);
      ball.vz *= -1;
      cameraShake = 0.2;
      playBounce();
    } else if (ball.z > bottomZ) {
      ball.z = bottomZ;
      spawnWallExplosion(ball.x, bottomZ);
      ball.vz *= -1;
      cameraShake = 0.2;
      playBounce();
    }

    // Paddle-Kollision
    const p1X = -FIELD_WIDTH / 2 + 1.0;
    const p2X =  FIELD_WIDTH / 2 - 1.0;

    function checkPaddleCollision(px, pz) {
      const paddleHalfH = paddleHeight / 2;
      const paddleHalfW = paddleWidth / 2 + ballRadius;
      const withinZ = ball.z > (pz - paddleHalfH) && ball.z < (pz + paddleHalfH);
      const closeX = Math.abs(ball.x - px) < paddleHalfW;
      return withinZ && closeX;
    }

    if (ball.vx < 0 && checkPaddleCollision(p1X, p1.z)) {
      variablePaddleBounce(true);
    } else if (ball.vx > 0 && checkPaddleCollision(p2X, p2.z)) {
      variablePaddleBounce(false);
    }

    const outX = FIELD_WIDTH / 2 + 1;
    if (ball.x < -outX) {
      score.p2++;
      scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
      playBounce();
      checkWinOrContinue(1);
    } else if (ball.x > outX) {
      score.p1++;
      scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
      playBounce();
      checkWinOrContinue(-1);
    }

    // Mesh-Positionen
    paddle1Mesh.position.z = p1.z;
    paddle2Mesh.position.z = p2.z;
    ballMesh.position.set(ball.x, ballRadius + 0.1, ball.z);

    updateBallTrail();
    updateExplosions(dt);

    // Kamera-Shake
    if (cameraShake > 0) {
      camera.position.x = (Math.random() - 0.5) * cameraShake;
      camera.position.y = 8 + (Math.random() - 0.5) * cameraShake;
      cameraShake -= dt * 2;
    } else {
      camera.position.x = 0;
      camera.position.y = 8;
    }
    camera.lookAt(0, 0, 0);
  }

  function checkWinOrContinue(lastDir) {
    if (score.p1 >= WIN_SCORE || score.p2 >= WIN_SCORE) {
      gameState = "gameover";
      let msg = "", sub = "";
      if (score.p1 > score.p2) {
        msg = "Player 1 Won!";
        sub = "Nice reflexes!";
      } else {
        if (gameMode === 0) {
          msg = "You lost against the CPU!";
          sub = "TRY HARDER!";
        } else {
          msg = "Player 2 Won!";
          sub = "Well played!";
        }
      }
      gameoverTitle.textContent = msg;
      gameoverSub.textContent = sub;
      gameoverOverlay.classList.remove("hidden");
    } else {
      resetBall(-lastDir);
    }
  }

  // ---------- Loop ----------
  const clock = new THREE.Clock();
  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const t = clock.getElapsedTime();

    const pulse = 0.6 + 0.4 * Math.sin(t * 2);
    wallMat.emissiveIntensity = 0.7 + 0.5 * pulse;
    midLineMat.opacity = 0.3 + 0.3 * (0.5 + 0.5 * Math.sin(t * 3));
    ballMat.emissiveIntensity = 2.0 + 0.6 * Math.sin(t * 5);
    paddleMat1.emissiveIntensity = 1.2 + 0.3 * Math.sin(t * 3);
    paddleMat2.emissiveIntensity = 1.2 + 0.3 * Math.sin(t * 3.5);

    ring.rotation.y += 0.002;
    ring2.rotation.y -= 0.0015;
    stars.rotation.y += 0.0001;

    if (gameState === "playing") {
      updateGame(dt);
    }

    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
</script>
</body>
</html>
