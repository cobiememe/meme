<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>CobiePong</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #050509;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }

    #game-wrapper {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #000;
    }

    canvas#three-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Score oben zentriert */
    #score {
      position: absolute;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 32px;
      font-weight: 700;
      text-shadow: 0 0 8px rgba(0,0,0,0.8);
      pointer-events: none;
      z-index: 5;
    }

    /* CRT / Scanline Overlay */
    #crt-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      mix-blend-mode: soft-light;
      opacity: 0.4;
      z-index: 4;
      background-image:
        repeating-linear-gradient(
          to bottom,
          rgba(0,0,0,0.55),
          rgba(0,0,0,0.55) 1px,
          rgba(0,0,0,0.0) 3px
        ),
        radial-gradient(circle at center, rgba(255,255,255,0.12), rgba(0,0,0,0.95));
    }

    /* Shared Overlay-Styling (Menu & Game Over) */
    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, rgba(255,255,255,0.08), rgba(0,0,0,0.9));
      z-index: 10;
    }

    .hidden {
      display: none;
    }

    /* CobiePong Titel */
    .title-row {
      display: flex;
      gap: 4px;
      margin-bottom: 18px;
      perspective: 800px;
    }

    .title-letter {
      font-size: 64px;
      font-weight: 900;
      display: inline-block;
      animation: bob 1.2s ease-in-out infinite;
      transform-origin: center bottom;
      text-shadow: 0 0 10px rgba(0,0,0,0.7);
    }

    .title-letter:nth-child(1) { animation-delay: 0s; }
    .title-letter:nth-child(2) { animation-delay: 0.08s; }
    .title-letter:nth-child(3) { animation-delay: 0.16s; }
    .title-letter:nth-child(4) { animation-delay: 0.24s; }
    .title-letter:nth-child(5) { animation-delay: 0.32s; }
    .title-letter:nth-child(6) { animation-delay: 0.40s; }
    .title-letter:nth-child(7) { animation-delay: 0.48s; }
    .title-letter:nth-child(8) { animation-delay: 0.56s; }
    .title-letter:nth-child(9) { animation-delay: 0.64s; }

    @keyframes bob {
      0%,100% {
        transform: translateY(0) rotateX(0deg);
      }
      50% {
        transform: translateY(-8px) rotateX(8deg);
      }
    }

    .menu-option {
      font-size: 26px;
      margin: 6px 0;
      padding: 4px 14px;
      border-radius: 999px;
      cursor: pointer;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.1);
      transition: transform 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }

    .menu-option span {
      background: linear-gradient(90deg, #ff5252, #ffd452, #4dff4d, #52c7ff, #d452ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .menu-option.selected {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 0 18px rgba(255,255,255,0.25);
      background: rgba(255,255,255,0.06);
    }

    .hint-text {
      margin-top: 20px;
      font-size: 18px;
      letter-spacing: 1px;
      text-shadow: 0 0 6px rgba(0,0,0,0.7);
    }

    .hint-text span {
      background: linear-gradient(90deg, #ffd452, #ff5252, #d452ff, #52c7ff, #4dff4d);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    /* Game Over Text */
    .gameover-title {
      font-size: 42px;
      font-weight: 800;
      margin-bottom: 12px;
      text-align: center;
      text-shadow: 0 0 10px rgba(0,0,0,0.9);
    }

    .gameover-sub {
      font-size: 20px;
      opacity: 0.9;
      margin-bottom: 28px;
      text-align: center;
    }

    .gameover-hint {
      font-size: 18px;
      opacity: 0.8;
    }

    @media (max-width: 768px) {
      .title-letter { font-size: 44px; }
      .menu-option { font-size: 20px; }
      .gameover-title { font-size: 32px; }
    }

    /* verstecktes Video als Texturquelle */
    #bgVideo {
      display: none;
    }
  </style>
</head>
<body>
<div id="game-wrapper">
  <!-- Hintergrund-Video als Texturquelle -->
  <video id="bgVideo" src="../video/spinningWorld.mp4" muted autoplay loop playsinline></video>

  <canvas id="three-canvas"></canvas>
  <div id="crt-overlay"></div>

  <div id="score">0 : 0</div>

  <!-- Start-Menü -->
  <div id="menu-overlay" class="overlay">
    <div class="title-row" id="cobie-title"></div>
    <div class="menu-option selected" data-mode="0"><span>Player vs CPU</span></div>
    <div class="menu-option" data-mode="1"><span>Player1 vs Player2</span></div>
    <div class="hint-text"><span>Press ENTER To Play</span></div>
  </div>

  <!-- Game Over -->
  <div id="gameover-overlay" class="overlay hidden">
    <div class="gameover-title" id="gameover-title">Player 1 Won!</div>
    <div class="gameover-sub" id="gameover-sub">Great job!</div>
    <div class="gameover-hint">Press ENTER to go back to menu</div>
  </div>
</div>

<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

  // ---------- Titel "CobiePong" bunt + wippend ----------
  const cobieTitle = document.getElementById("cobie-title");
  const cobieText = "CobiePong";
  const colorPalette = ["#4285F4", "#EA4335", "#FBBC05", "#34A853", "#A142F4"];

  for (let i = 0; i < cobieText.length; i++) {
    const span = document.createElement("span");
    span.className = "title-letter";
    span.textContent = cobieText[i];
    span.style.color = colorPalette[i % colorPalette.length];
    cobieTitle.appendChild(span);
  }

  // ---------- Game State ----------
  let gameState = "menu"; // "menu" | "playing" | "gameover"
  let gameMode = 0;       // 0 = PvCPU, 1 = PvP
  let menuIndex = 0;
  const WIN_SCORE = 5;

  const menuOverlay = document.getElementById("menu-overlay");
  const gameoverOverlay = document.getElementById("gameover-overlay");
  const gameoverTitle = document.getElementById("gameover-title");
  const gameoverSub = document.getElementById("gameover-sub");
  const scoreDisplay = document.getElementById("score");
  const menuOptions = Array.from(document.querySelectorAll(".menu-option"));

  function updateMenuVisual() {
    menuOptions.forEach((opt, i) => {
      opt.classList.toggle("selected", i === menuIndex);
    });
  }

  // ---------- Three.js Setup ----------
  const canvas = document.getElementById("three-canvas");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;

  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
  camera.position.set(0, 8, 16);
  camera.lookAt(0, 0, 0);

  // Postprocessing: Bloom
  const composer = new EffectComposer(renderer);
  const renderPass = new RenderPass(scene, camera);
  composer.addPass(renderPass);

  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    0.9,  // strength
    0.4,  // radius
    0.85  // threshold
  );
  composer.addPass(bloomPass);

  // Licht
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const spot = new THREE.SpotLight(0x66ccff, 1.3, 60, Math.PI / 4, 0.4, 1.5);
  spot.position.set(0, 16, 10);
  spot.target.position.set(0, 0, 0);
  scene.add(spot);
  scene.add(spot.target);

  // Hintergrund-Video als Plane hinter dem Spielfeld
  const bgVideo = document.getElementById("bgVideo");
  bgVideo.play().catch(() => {});
  const videoTex = new THREE.VideoTexture(bgVideo);
  videoTex.encoding = THREE.sRGBEncoding;

  const bgGeom = new THREE.PlaneGeometry(40, 22);
  const bgMat = new THREE.MeshBasicMaterial({ map: videoTex });
  const bgMesh = new THREE.Mesh(bgGeom, bgMat);
  bgMesh.position.set(0, 6, -25);
  scene.add(bgMesh);

  // Spielfeld
  const FIELD_WIDTH = 16;
  const FIELD_HEIGHT = 9;

  const fieldGeom = new THREE.PlaneGeometry(FIELD_WIDTH, FIELD_HEIGHT);
  const fieldMat = new THREE.MeshStandardMaterial({
    color: 0x10131f,
    metalness: 0.4,
    roughness: 0.5
  });
  const field = new THREE.Mesh(fieldGeom, fieldMat);
  field.rotation.x = -Math.PI / 2;
  scene.add(field);

  // Mittellinie
  const midLineGeom = new THREE.PlaneGeometry(0.08, FIELD_HEIGHT);
  const midLineMat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    opacity: 0.4,
    transparent: true
  });
  const midLine = new THREE.Mesh(midLineGeom, midLineMat);
  midLine.position.set(0, 0.01, 0);
  midLine.rotation.x = -Math.PI / 2;
  scene.add(midLine);

  // Walls mit stärkerem Glow
  const wallMat = new THREE.MeshStandardMaterial({
    color: 0x293c7a,
    emissive: 0x112266,
    emissiveIntensity: 0.7,
    metalness: 0.7,
    roughness: 0.35
  });
  const wallThickness = 0.3;
  const wallHeight = 0.5;
  const wallGeomH = new THREE.BoxGeometry(FIELD_WIDTH, wallHeight, wallThickness);
  const wallGeomV = new THREE.BoxGeometry(wallThickness, wallHeight, FIELD_HEIGHT);

  const wallTop = new THREE.Mesh(wallGeomH, wallMat);
  wallTop.position.set(0, wallHeight/2, -FIELD_HEIGHT/2);
  const wallBottom = wallTop.clone();
  wallBottom.position.set(0, wallHeight/2, FIELD_HEIGHT/2);

  const wallLeft = new THREE.Mesh(wallGeomV, wallMat);
  wallLeft.position.set(-FIELD_WIDTH/2, wallHeight/2, 0);
  const wallRight = wallLeft.clone();
  wallRight.position.set(FIELD_WIDTH/2, wallHeight/2, 0);

  scene.add(wallTop, wallBottom, wallLeft, wallRight);

  // Paddles
  const paddleWidth = 0.4;
  const paddleHeight = 2.0;
  const paddleDepth = 0.4;

  const paddleGeom = new THREE.BoxGeometry(paddleWidth, paddleDepth, paddleHeight);
  const paddleMat1 = new THREE.MeshStandardMaterial({
    color: 0x52c7ff,
    emissive: 0x115577,
    emissiveIntensity: 1.2
  });
  const paddleMat2 = new THREE.MeshStandardMaterial({
    color: 0xff52a9,
    emissive: 0x771144,
    emissiveIntensity: 1.2
  });

  const paddle1Mesh = new THREE.Mesh(paddleGeom, paddleMat1);
  const paddle2Mesh = new THREE.Mesh(paddleGeom, paddleMat2);

  paddle1Mesh.position.set(-FIELD_WIDTH/2 + 1.0, paddleDepth/2, 0);
  paddle2Mesh.position.set(FIELD_WIDTH/2 - 1.0, paddleDepth/2, 0);

  scene.add(paddle1Mesh, paddle2Mesh);

  // Ball mit Glow
  const ballRadius = 0.25;
  const ballGeom = new THREE.SphereGeometry(ballRadius, 32, 32);
  const ballMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    emissive: 0x44aaff,
    emissiveIntensity: 2.0,
    metalness: 0.7,
    roughness: 0.2
  });
  const ballMesh = new THREE.Mesh(ballGeom, ballMat);
  ballMesh.position.set(0, ballRadius + 0.1, 0);
  scene.add(ballMesh);

  // Ball-Trail: mehrere kleine Kugeln
  const trailCount = 14;
  const trailMeshes = [];
  const trailMatTemplate = new THREE.MeshBasicMaterial({
    color: 0x44aaff,
    transparent: true,
    opacity: 0.0
  });
  for (let i = 0; i < trailCount; i++) {
    const tGeom = new THREE.SphereGeometry(ballRadius * 0.9, 16, 16);
    const tMat = trailMatTemplate.clone();
    const tMesh = new THREE.Mesh(tGeom, tMat);
    tMesh.visible = true;
    scene.add(tMesh);
    trailMeshes.push(tMesh);
  }
  let trailIndex = 0;

  function updateBallTrail() {
    const current = trailMeshes[trailIndex];
    current.position.copy(ballMesh.position);
    current.material.opacity = 0.7;
    current.scale.set(1, 1, 1);

    trailIndex = (trailIndex + 1) % trailCount;

    for (let i = 0; i < trailCount; i++) {
      if (i !== trailIndex) {
        const m = trailMeshes[i];
        m.material.opacity *= 0.86;
        m.scale.multiplyScalar(0.96);
      }
    }
  }

  // Neon-Explosionen (Partikel) bei Wandkontakt
  const explosions = [];
  function spawnWallExplosion(x, z) {
    const count = 22;
    for (let i = 0; i < count; i++) {
      const g = new THREE.SphereGeometry(0.08, 8, 8);
      const m = new THREE.MeshBasicMaterial({
        color: (i % 2 === 0) ? 0x44ccff : 0xff44aa,
        transparent: true,
        opacity: 1.0
      });
      const mesh = new THREE.Mesh(g, m);
      mesh.position.set(x, ballRadius + 0.15, z);
      scene.add(mesh);

      const angle = Math.random() * Math.PI * 2;
      const speed = 0.07 + Math.random() * 0.12;
      const vy = 0.02 + Math.random() * 0.04;
      explosions.push({
        mesh,
        vx: Math.cos(angle) * speed,
        vz: Math.sin(angle) * speed,
        vy,
        life: 0.5 + Math.random() * 0.4
      });
    }
  }

  function updateExplosions(dt) {
    for (let i = explosions.length - 1; i >= 0; i--) {
      const e = explosions[i];
      e.life -= dt;
      if (e.life <= 0) {
        scene.remove(e.mesh);
        explosions.splice(i, 1);
        continue;
      }
      e.mesh.position.x += e.vx;
      e.mesh.position.z += e.vz;
      e.mesh.position.y += e.vy;
      e.vy -= 0.004;
      e.mesh.material.opacity = Math.max(0, e.life * 2);
      e.mesh.scale.multiplyScalar(0.985);
    }
  }

  // Hintergrund-Deko: Neon-Ringe (leicht angepasst)
  const ringGeom = new THREE.TorusGeometry(FIELD_WIDTH/2.2, 0.03, 16, 100);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x333366 });
  const ring = new THREE.Mesh(ringGeom, ringMat);
  ring.rotation.x = Math.PI/2;
  ring.position.y = 0.02;
  scene.add(ring);

  const ring2Geom = new THREE.TorusGeometry(FIELD_WIDTH/3, 0.02, 16, 100);
  const ring2Mat = new THREE.MeshBasicMaterial({ color: 0x223344 });
  const ring2 = new THREE.Mesh(ring2Geom, ring2Mat);
  ring2.rotation.x = Math.PI/2;
  ring2.position.y = 0.03;
  scene.add(ring2);

  // ---------- Spiel-Logik (X/Z) ----------

  let keys = {};
  let p1 = { z: 0 };
  let p2 = { z: 0 };

  const BALL_BASE_SPEED = 0.16;
  let ball = { x: 0, z: 0, vx: BALL_BASE_SPEED, vz: 0.0 };
  let hitCount = 0;
  let score = { p1: 0, p2: 0 };

  function calculateSpeedMultiplier(hitCount) {
    if (hitCount <= 5) {
      return 1 + hitCount * 0.2; // bis +100%
    }
    if (hitCount < 10) {
      return 2.0; // +100%
    }
    return 3.0; // +200%
  }

  function resetBall(direction = 1) {
    ball.x = 0;
    ball.z = 0;
    hitCount = 0;

    const maxAngle = Math.PI / 4; // ±45°
    const angle = (Math.random() * 2 - 1) * maxAngle;
    const dirX = direction >= 0 ? 1 : -1;
    ball.vx = Math.cos(angle) * BALL_BASE_SPEED * dirX;
    ball.vz = Math.sin(angle) * BALL_BASE_SPEED;
  }

  function resetGameToMenu() {
    score.p1 = 0;
    score.p2 = 0;
    scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
    p1.z = 0;
    p2.z = 0;
    resetBall(1);
    gameState = "menu";
    menuOverlay.classList.remove("hidden");
    gameoverOverlay.classList.add("hidden");
  }

  resetBall(1);

  // Eingaben
  document.addEventListener("keydown", (e) => {
    keys[e.key] = true;

    if (gameState === "menu") {
      if (e.key === "ArrowUp" || e.key === "ArrowDown") {
        menuIndex = menuIndex === 0 ? 1 : 0;
        updateMenuVisual();
      }
      if (e.key === "Enter") {
        gameMode = menuIndex;
        menuOverlay.classList.add("hidden");
        gameoverOverlay.classList.add("hidden");
        gameState = "playing";
        resetBall(1);
      }
    } else if (gameState === "gameover") {
      if (e.key === "Enter") {
        resetGameToMenu();
      }
    }
  });

  document.addEventListener("keyup", (e) => {
    keys[e.key] = false;
  });

  function variablePaddleBounce(isLeftPaddle) {
    const paddleZ = isLeftPaddle ? p1.z : p2.z;
    const rel = (ball.z - paddleZ) / (paddleHeight / 2);
    const clamped = Math.max(-1, Math.min(1, rel));
    const maxAngle = Math.PI / 3; // bis 60°
    const angle = clamped * maxAngle;

    const dirX = isLeftPaddle ? 1 : -1;
    ball.vx = Math.cos(angle) * BALL_BASE_SPEED * dirX;
    ball.vz = Math.sin(angle) * BALL_BASE_SPEED;
  }

  function updateGame(dt) {
    const paddleSpeed = 0.22;

    // Player 1
    if (keys["w"]) p1.z -= paddleSpeed;
    if (keys["s"]) p1.z += paddleSpeed;

    const maxZ = FIELD_HEIGHT/2 - paddleHeight/2;
    p1.z = Math.max(-maxZ, Math.min(maxZ, p1.z));

    // Player 2 / CPU
    if (gameMode === 1) {
      if (keys["ArrowUp"]) p2.z -= paddleSpeed;
      if (keys["ArrowDown"]) p2.z += paddleSpeed;
      p2.z = Math.max(-maxZ, Math.min(maxZ, p2.z));
    } else {
      const cpuSpeed = 0.18;
      if (ball.z < p2.z - 0.2) p2.z -= cpuSpeed;
      if (ball.z > p2.z + 0.2) p2.z += cpuSpeed;
      p2.z = Math.max(-maxZ, Math.min(maxZ, p2.z));
    }

    // Ballbewegung
    const speedMult = calculateSpeedMultiplier(hitCount);
    ball.x += ball.vx * speedMult;
    ball.z += ball.vz * speedMult;

    // Wandkollision (oben/unten) = Explosion
    const topZ = -FIELD_HEIGHT/2 + ballRadius;
    const bottomZ = FIELD_HEIGHT/2 - ballRadius;
    if (ball.z < topZ) {
      ball.z = topZ;
      spawnWallExplosion(ball.x, topZ);
      ball.vz *= -1;
    } else if (ball.z > bottomZ) {
      ball.z = bottomZ;
      spawnWallExplosion(ball.x, bottomZ);
      ball.vz *= -1;
    }

    // Paddle-Kollision
    const p1X = -FIELD_WIDTH/2 + 1.0;
    const p2X = FIELD_WIDTH/2 - 1.0;

    function checkPaddleCollision(px, pz) {
      const paddleHalfH = paddleHeight/2;
      const paddleHalfW = paddleWidth/2 + ballRadius;
      const withinZ = ball.z > (pz - paddleHalfH) && ball.z < (pz + paddleHalfH);
      const closeX = Math.abs(ball.x - px) < paddleHalfW;
      return withinZ && closeX;
    }

    if (checkPaddleCollision(p1X, p1.z) && ball.vx < 0) {
      variablePaddleBounce(true);
      hitCount++;
    }

    if (checkPaddleCollision(p2X, p2.z) && ball.vx > 0) {
      variablePaddleBounce(false);
      hitCount++;
    }

    // Punkte
    if (ball.x < -FIELD_WIDTH/2 - 1) {
      score.p2++;
      scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
      checkWinOrContinue(-1);
    } else if (ball.x > FIELD_WIDTH/2 + 1) {
      score.p1++;
      scoreDisplay.textContent = `${score.p1} : ${score.p2}`;
      checkWinOrContinue(1);
    }

    // Meshes updaten
    paddle1Mesh.position.z = p1.z;
    paddle2Mesh.position.z = p2.z;
    ballMesh.position.set(ball.x, ballRadius + 0.1, ball.z);

    // Ball-Trail & Explosionen
    updateBallTrail();
    updateExplosions(dt);
  }

  function checkWinOrContinue(lastDirection) {
    if (score.p1 >= WIN_SCORE || score.p2 >= WIN_SCORE) {
      gameState = "gameover";
      let msg = "";
      let sub = "";
      if (score.p1 > score.p2) {
        msg = "Player 1 Won!";
        sub = "Nice reflexes!";
      } else {
        if (gameMode === 0) {
          msg = "You loose against an CPU!";
          sub = "Try Harder!";
        } else {
          msg = "Player 2 Won!";
          sub = "Well played!";
        }
      }
      gameoverTitle.textContent = msg;
      gameoverSub.textContent = sub;
      gameoverOverlay.classList.remove("hidden");
    } else {
      resetBall(-lastDirection);
    }
  }

  // ---------- Animation Loop ----------
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const t = clock.getElapsedTime();

    // kleine VFX: Walls & Midline pulsieren
    const pulse = 0.6 + 0.4 * Math.sin(t * 2.0);
    wallMat.emissiveIntensity = 0.6 + 0.4 * pulse;
    midLineMat.opacity = 0.25 + 0.25 * (0.5 + 0.5 * Math.sin(t * 3.0));

    ring.rotation.y += 0.0015;
    ring2.rotation.y -= 0.001;

    if (gameState === "playing") {
      updateGame(dt);
    }

    composer.render();
  }

  animate();

  window.addEventListener("resize", () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
