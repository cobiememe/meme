<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Web3 NFT Cube Gallery</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: 'Courier New', monospace;
    }

    canvas {
      display: block;
    }

    /* ===== TITLE SCREEN ===== */
    #title-screen {
      position: fixed;
      inset: 0;
      background: #000;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: opacity 1s;
    }

    #title-screen.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #title-canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
    }

    .title-content {
      position: relative;
      z-index: 10;
      text-align: center;
      pointer-events: none;
    }

    .subtitle {
      font-size: 16px;
      color: #00eaff;
      opacity: 0.7;
      animation: pulse 2s ease-in-out infinite;
      letter-spacing: 3px;
      text-transform: uppercase;
      margin-top: 40px;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }

    /* ===== REVEAL SCREEN ===== */
    #reveal-screen {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      display: none;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.5s ease;
    }

    #reveal-screen.active {
      display: flex;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .reveal-container {
      display: flex;
      gap: 40px;
      align-items: center;
      max-width: 90vw;
    }

    .reveal-image {
      width: 480px;
      height: 720px;
      border-radius: 16px;
      border: 3px solid #00eaff;
      box-shadow: 0 0 40px rgba(0, 234, 255, 0.6);
      animation: zoomIn 1s ease;
      object-fit: cover;
    }

    @keyframes zoomIn {
      from {
        transform: scale(0.5) rotateY(180deg);
        opacity: 0;
      }
      to {
        transform: scale(1) rotateY(0deg);
        opacity: 1;
      }
    }

    .reveal-message {
      max-width: 400px;
      padding: 32px;
      background: linear-gradient(135deg, rgba(0, 234, 255, 0.1), rgba(153, 69, 255, 0.1));
      border: 2px solid #00eaff;
      border-radius: 16px;
      animation: slideIn 1s ease 0.5s both;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100px);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .reveal-message h2 {
      color: #00eaff;
      font-size: 28px;
      margin: 0 0 20px 0;
      text-shadow: 0 0 10px #00eaff;
    }

    .reveal-message p {
      color: #dff;
      font-size: 16px;
      line-height: 1.8;
      margin-bottom: 30px;
    }

    .reveal-message button {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #00eaff, #00bfff);
      border: none;
      border-radius: 10px;
      color: #000;
      font-weight: bold;
      font-size: 16px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .reveal-message button:hover {
      box-shadow: 0 0 30px rgba(0, 234, 255, 0.8);
      transform: translateY(-2px);
    }

    @media (max-width: 1200px) {
      .reveal-container {
        flex-direction: column;
      }
      .reveal-image {
        width: 360px;
        height: 540px;
      }
    }

    /* ===== MAIN UI ===== */
    #ui {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      opacity: 0;
      transition: opacity 1s 1s;
    }

    #ui.visible {
      opacity: 1;
    }

    #wallet-btn {
      padding: 12px 24px;
      background: rgba(0, 234, 255, 0.2);
      border: 2px solid #00eaff;
      color: #00eaff;
      font-weight: bold;
      cursor: pointer;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.3s;
      text-shadow: 0 0 10px #00eaff;
    }

    #wallet-btn:hover {
      background: #00eaff;
      color: #000;
      box-shadow: 0 0 20px #00eaff;
    }

    #info {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid #00eaff;
      font-size: 12px;
      color: #00eaff;
      opacity: 0;
      transition: opacity 1s 1s;
    }

    #info.visible {
      opacity: 1;
    }

    #info h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
    }

    .cube-label {
      position: fixed;
      background: rgba(0, 234, 255, 0.9);
      color: #000;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: bold;
      pointer-events: none;
      display: none;
    }

    /* ===== MESSAGE MODAL ===== */
    .message-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      backdrop-filter: blur(4px);
    }

    .message-modal.active {
      display: flex;
    }

    .message-modal-content {
      background: linear-gradient(180deg, rgba(17, 24, 39, 0.95), rgba(7, 10, 16, 0.95));
      padding: 32px;
      border-radius: 16px;
      width: min(500px, 90vw);
      border: 2px solid #00eaff;
      box-shadow: 0 0 40px rgba(0, 234, 255, 0.5);
      animation: modalSlide 0.3s ease;
    }

    @keyframes modalSlide {
      from {
        opacity: 0;
        transform: translateY(-50px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .message-modal h2 {
      margin: 0 0 20px 0;
      color: #00eaff;
      font-size: 22px;
      text-align: center;
      text-shadow: 0 0 10px #00eaff;
    }

    .message-modal textarea {
      width: 100%;
      min-height: 120px;
      padding: 12px;
      border-radius: 8px;
      border: 2px solid #00eaff;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      font-size: 14px;
      font-family: inherit;
      resize: vertical;
      margin-bottom: 10px;
    }

    .message-modal textarea:focus {
      outline: none;
      box-shadow: 0 0 15px rgba(0, 234, 255, 0.5);
    }

    .char-counter {
      text-align: right;
      font-size: 11px;
      color: #00eaff;
      margin-bottom: 20px;
    }

    .message-display {
      background: rgba(0, 234, 255, 0.1);
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #00eaff;
      margin-bottom: 20px;
      color: #dff;
      line-height: 1.6;
      max-height: 200px;
      overflow-y: auto;
    }

    .message-display em {
      color: #888;
      font-style: italic;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
    }

    .modal-buttons button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }

    .btn-cancel {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .btn-cancel:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-save {
      background: linear-gradient(135deg, #00eaff, #00bfff);
      color: #000;
      border: none;
    }

    .btn-save:hover {
      box-shadow: 0 0 20px rgba(0, 234, 255, 0.8);
      transform: translateY(-2px);
    }

    .btn-save:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.161.0/build/three.module.min.js",
        "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/",
        "@solana/web3.js": "https://esm.sh/@solana/web3.js@1.87.6"
      }
    }
  </script>
</head>

<body>
  <!-- TITLE SCREEN -->
  <div id="title-screen">
    <canvas id="title-canvas"></canvas>
    <div class="title-content">
      <p class="subtitle">Click to continue</p>
    </div>
  </div>

  <!-- REVEAL SCREEN -->
  <div id="reveal-screen">
    <div class="reveal-container">
      <img id="reveal-image" class="reveal-image" src="" alt="Mystery Revealed" />
      <div class="reveal-message">
        <h2>🎉 Secret Revealed!</h2>
        <p>You've discovered a hidden mystery. This unique piece is waiting for collectors like you in the gallery.</p>
        <button id="reveal-continue">Enter Gallery →</button>
      </div>
    </div>
  </div>

  <!-- MAIN UI -->
  <div id="ui">
    <button id="wallet-btn">Connect Phantom Wallet</button>
  </div>

  <div id="info">
    <h3>🎲 Mystery Box Gallery</h3>
    <p>Click on a box to reveal NFT</p>
    <p>Cost: 0.001 SOL per box</p>
    <p>20 unique images available!</p>
  </div>

  <div id="cube-label" class="cube-label"></div>

  <!-- MESSAGE MODAL -->
  <div id="messageModal" class="message-modal">
    <div class="message-modal-content">
      <h2 id="messageModalTitle">💬 Add Message</h2>
      
      <div id="messageDisplay" class="message-display" style="display:none;">
        <p id="messageText"></p>
      </div>

      <div id="messageEditArea" style="display:none;">
        <textarea id="messageInput" placeholder="Write your message for this NFT..." maxlength="200"></textarea>
        <div class="char-counter"><span id="messageCharCount">0</span>/200</div>
      </div>

      <div class="modal-buttons">
        <button class="btn-cancel" id="messageModalClose">Close</button>
        <button class="btn-save" id="messageModalSave" style="display:none;">Save Message</button>
      </div>
    </div>
  </div>

  <!-- AUDIO -->
  <audio id="background-music" loop>
    <source src="https://raw.githubusercontent.com/cobiememe/meme/main/sounds/Mystic7.mp3" type="audio/mpeg">
  </audio>

  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // ===== SUPABASE SETUP =====
    const SUPABASE_URL = 'https://nigwdyolfgixcejslaue.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5pZ3dkeW9sZmdpeGNlanNsYXVlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAwNTMzNzMsImV4cCI6MjA3NTYyOTM3M30.u3g0vzcuF6LstbnsrYyzl1TezJa-lKkd0xk55iddoyw';
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    console.log('💾 Supabase connected!');

    // ===== TITLE SCREEN 3D TEXT ANIMATION =====
    const titleCanvas = document.getElementById('title-canvas');
    const titleRenderer = new THREE.WebGLRenderer({ canvas: titleCanvas, antialias: true, alpha: true });
    titleRenderer.setSize(window.innerWidth, window.innerHeight);
    titleRenderer.setPixelRatio(window.devicePixelRatio);

    const titleScene = new THREE.Scene();
    const titleCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    titleCamera.position.z = 25;

    // Add lights for title scene
    const titleAmbient = new THREE.AmbientLight(0xffffff, 0.5);
    titleScene.add(titleAmbient);
    
    const titlePointLight1 = new THREE.PointLight(0x00eaff, 1, 100);
    titlePointLight1.position.set(10, 10, 10);
    titleScene.add(titlePointLight1);
    
    const titlePointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
    titlePointLight2.position.set(-10, -10, 10);
    titleScene.add(titlePointLight2);

    // Load font and create 3D text
    const titlePolygons = [];
    const loader = new THREE.FontLoader();
    
    loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', function(font) {
      // Create "COBIE'S NFT SPACE" text
      const textMaterial1 = new THREE.MeshStandardMaterial({
        color: 0x00eaff,
        emissive: 0x00eaff,
        emissiveIntensity: 0.5,
        metalness: 0.8,
        roughness: 0.2
      });
      
      const textMaterial2 = new THREE.MeshStandardMaterial({
        color: 0xff00ff,
        emissive: 0xff00ff,
        emissiveIntensity: 0.5,
        metalness: 0.8,
        roughness: 0.2
      });
      
      const textMaterial3 = new THREE.MeshStandardMaterial({
        color: 0x00ff88,
        emissive: 0x00ff88,
        emissiveIntensity: 0.5,
        metalness: 0.8,
        roughness: 0.2
      });

      // First line: "COBIE'S"
      const geo1 = new THREE.TextGeometry("COBIE'S", {
        font: font,
        size: 3,
        height: 1,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.3,
        bevelSize: 0.1,
        bevelSegments: 5
      });
      geo1.center();
      const text1 = new THREE.Mesh(geo1, textMaterial1);
      text1.position.y = 5;
      text1.userData = { rotSpeedX: 0.005, rotSpeedY: 0.01, exploding: false, velocity: new THREE.Vector3() };
      titleScene.add(text1);
      titlePolygons.push(text1);

      // Second line: "NFT"
      const geo2 = new THREE.TextGeometry("NFT", {
        font: font,
        size: 3,
        height: 1,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.3,
        bevelSize: 0.1,
        bevelSegments: 5
      });
      geo2.center();
      const text2 = new THREE.Mesh(geo2, textMaterial2);
      text2.position.y = 0;
      text2.userData = { rotSpeedX: 0.008, rotSpeedY: 0.008, exploding: false, velocity: new THREE.Vector3() };
      titleScene.add(text2);
      titlePolygons.push(text2);

      // Third line: "SPACE"
      const geo3 = new THREE.TextGeometry("SPACE", {
        font: font,
        size: 3,
        height: 1,
        curveSegments: 12,
        bevelEnabled: true,
        bevelThickness: 0.3,
        bevelSize: 0.1,
        bevelSegments: 5
      });
      geo3.center();
      const text3 = new THREE.Mesh(geo3, textMaterial3);
      text3.position.y = -5;
      text3.userData = { rotSpeedX: 0.007, rotSpeedY: 0.006, exploding: false, velocity: new THREE.Vector3() };
      titleScene.add(text3);
      titlePolygons.push(text3);
    });

    // Animate title text
    let titleAnimating = true;
    
    function animateTitlePolygons() {
      if (!titleAnimating) return;
      
      titlePolygons.forEach(text => {
        if (text.userData.exploding) {
          // Explosion animation
          text.position.add(text.userData.velocity);
          text.userData.velocity.multiplyScalar(1.08);
          text.rotation.x += text.userData.rotSpeedX * 10;
          text.rotation.y += text.userData.rotSpeedY * 10;
          
          // Fade out
          text.material.opacity -= 0.02;
          if (text.material.opacity <= 0) {
            text.visible = false;
          }
        } else {
          // Normal rotation
          text.rotation.x += text.userData.rotSpeedX;
          text.rotation.y += text.userData.rotSpeedY;
        }
      });
      
      // Animate lights
      titlePointLight1.position.x = Math.sin(Date.now() * 0.001) * 15;
      titlePointLight1.position.y = Math.cos(Date.now() * 0.001) * 15;
      
      titlePointLight2.position.x = Math.cos(Date.now() * 0.0015) * 15;
      titlePointLight2.position.y = Math.sin(Date.now() * 0.0015) * 15;
      
      titleRenderer.render(titleScene, titleCamera);
      requestAnimationFrame(animateTitlePolygons);
    }
    animateTitlePolygons();

    // Handle resize
    window.addEventListener('resize', () => {
      titleCamera.aspect = window.innerWidth / window.innerHeight;
      titleCamera.updateProjectionMatrix();
      titleRenderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ===== TITLE SCREEN CLICK =====
    let titleScreenHidden = false;
    let animationStarted = false;
    const titleScreen = document.getElementById('title-screen');
    const revealScreen = document.getElementById('reveal-screen');
    const bgMusic = document.getElementById('background-music');

    titleScreen.addEventListener('click', () => {
      console.log('Title screen clicked!');
      
      // Start explosion animation
      titlePolygons.forEach(text => {
        text.userData.exploding = true;
        text.material.transparent = true;
        text.material.opacity = 1;
        
        // Set random explosion velocity towards camera
        const direction = new THREE.Vector3(
          (Math.random() - 0.5) * 3,
          (Math.random() - 0.5) * 3,
          Math.random() * 3 + 2
        );
        text.userData.velocity = direction.multiplyScalar(0.15);
      });
      
      // Pick random image
      const randomImageIndex = Math.floor(Math.random() * 20) + 1;
      const randomImageUrl = `https://raw.githubusercontent.com/cobiememe/meme/main/img/img${randomImageIndex}.png`;
      
      document.getElementById('reveal-image').src = randomImageUrl;
      
      // Show reveal screen after explosion
      setTimeout(() => {
        titleAnimating = false;
        titleScreen.classList.add('hidden');
        revealScreen.classList.add('active');
        
        // Start music
        bgMusic.play().catch(e => console.log('Music autoplay blocked:', e));
      }, 2000);
    });

    // Reveal screen continue button
    document.getElementById('reveal-continue').addEventListener('click', () => {
      revealScreen.classList.remove('active');
      document.getElementById('ui').classList.add('visible');
      document.getElementById('info').classList.add('visible');
      
      setTimeout(() => {
        titleScreen.style.display = 'none';
        revealScreen.style.display = 'none';
      }, 1000);
      
      // Start 3D animation
      if (!animationStarted) {
        animationStarted = true;
        loadMintedBoxes();
        animate();
      }
    });

    // ===== SCENE SETUP =====
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a0f);
    scene.fog = new THREE.Fog(0x0a0a0f, 10, 50);

    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(8, 6, 8);

    // ===== CONTROLS =====
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 30;

    // ===== LIGHTS =====
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0x00eaff, 1);
    mainLight.position.set(5, 10, 5);
    mainLight.castShadow = true;
    scene.add(mainLight);

    const pointLight1 = new THREE.PointLight(0xff00ff, 0.5, 20);
    pointLight1.position.set(-5, 3, -5);
    scene.add(pointLight1);

    const pointLight2 = new THREE.PointLight(0x00ff88, 0.5, 20);
    pointLight2.position.set(5, 3, 5);
    scene.add(pointLight2);

    // ===== GRID FLOOR =====
    const gridHelper = new THREE.GridHelper(30, 30, 0x00eaff, 0x004466);
    scene.add(gridHelper);

    // ===== CREATE FLOATING CUBES =====
    const cubes = [];
    const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);

    // Create 20 cubes in a circular pattern
    const numCubes = 20;
    const radius = 8;

    // Load textures for mystery boxes
    const textureLoader = new THREE.TextureLoader();
    const mysteryImages = [];
    const imageMessages = {
      1: "🎨 Genesis #1: The first stroke of digital brilliance. This piece marks the beginning of an extraordinary collection.",
      2: "💎 Rare Gem #2: A masterpiece from the vault. Only the most discerning collectors recognize true value.",
      3: "🍀 Lucky Charm #3: Legend says this brings fortune to its owner. Your destiny awaits.",
      4: "🌟 Stellar Vision #4: Born from stardust and dreams. This NFT transcends the ordinary.",
      5: "🔥 Fire Spirit #5: Burning with creativity and passion. Feel the energy radiating from this piece.",
      6: "🌊 Ocean Deep #6: Dive into the depths of imagination. Mysteries lurk beneath the surface.",
      7: "🎭 Theatrical #7: Drama, elegance, and sophistication combined in one extraordinary creation.",
      8: "⚡ Thunder Strike #8: Raw power captured in digital form. This piece commands attention.",
      9: "🌸 Blossom #9: Beauty in its purest form. Watch as this artwork blooms in your collection.",
      10: "🦄 Mythical #10: Rare as a unicorn. This piece exists in the realm between reality and fantasy.",
      11: "🎪 Spectacular #11: Step right up! The greatest show in the digital art world.",
      12: "🌙 Lunar Magic #12: Moonlight captured forever. This piece glows with celestial energy.",
      13: "🏆 Champion #13: Victory embodied. Only champions recognize championship quality.",
      14: "🎵 Harmony #14: Visual symphony. Let this artwork sing to your soul.",
      15: "🗝️ Key to Mystery #15: Unlock secrets with this enigmatic piece. What will you discover?",
      16: "👑 Royal #16: Fit for digital royalty. Claim your throne in the NFT kingdom.",
      17: "🌈 Spectrum #17: All colors of possibility. This piece defies categorization.",
      18: "⭐ Cosmic #18: From beyond the stars. Intergalactic creativity at its finest.",
      19: "🎁 Gift #19: A present from the blockchain gods. You've been chosen.",
      20: "🔮 Oracle #20: The final prophecy. This piece completes the collection's mystical journey."
    };
    
    for (let i = 1; i <= 20; i++) {
      mysteryImages.push(`https://raw.githubusercontent.com/cobiememe/meme/main/img/img${i}.png`);
    }

    for (let i = 0; i < numCubes; i++) {
      const angle = (i / numCubes) * Math.PI * 2;
      const x = Math.cos(angle) * radius;
      const z = Math.sin(angle) * radius;
      const y = Math.sin(i * 0.5) * 2 + 2;

      // Random vibrant colors for unminted cubes
      const colors = [0x00eaff, 0xff00ff, 0x00ff88, 0xffaa00, 0xff0066, 0x00ffff];
      const color = colors[i % colors.length];

      const material = new THREE.MeshStandardMaterial({
        color: color,
        emissive: color,
        emissiveIntensity: 0.3,
        metalness: 0.7,
        roughness: 0.3
      });

      const cube = new THREE.Mesh(cubeGeometry, material);
      cube.position.set(x, y, z);
      cube.castShadow = true;
      cube.userData = {
        id: i,
        originalY: y,
        speed: 0.3 + Math.random() * 0.5,
        rotSpeed: 0.01 + Math.random() * 0.02,
        isMinted: false,
        mysteryImage: mysteryImages[i],
        originalColor: color,
        imageMessage: imageMessages[i + 1] // Messages are 1-indexed
      };

      scene.add(cube);
      cubes.push(cube);
    }

    // ===== LOAD MINTED BOXES FROM DATABASE =====
    async function loadMintedBoxes() {
      try {
        console.log('📥 Loading minted boxes from database...');
        const { data, error } = await supabase.from('minted_boxes').select('*');
        if (error) throw error;

        console.log('✅ Loaded', data.length, 'minted boxes');

        // Apply minted status to cubes
        data.forEach(mintedBox => {
          const cube = cubes.find(c => c.userData.id === mintedBox.box_id);
          if (cube) {
            cube.userData.isMinted = true;
            cube.userData.owner = mintedBox.wallet_address;
            cube.userData.message = mintedBox.message;
            cube.userData.mintedAt = mintedBox.minted_at;

            // Load texture
            textureLoader.load(
              cube.userData.mysteryImage,
              (texture) => {
                cube.material = new THREE.MeshStandardMaterial({
                  map: texture,
                  metalness: 0.3,
                  roughness: 0.5,
                  emissive: new THREE.Color(0xffd700),
                  emissiveIntensity: 0.5
                });
              }
            );
          }
        });
      } catch (e) {
        console.error('❌ Failed to load minted boxes:', e);
      }
    }

    // ===== RAYCASTER FOR CLICKING =====
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredCube = null;

    // ===== WALLET STATE =====
    let walletConnected = false;
    let walletAddress = null;

    // ===== WALLET FUNCTIONS =====
    function getProvider() {
      return window.phantom?.solana || window.solana || null;
    }

    async function connectWallet() {
      const provider = getProvider();
      if (!provider) {
        alert('⚠️ Phantom Wallet not found! Please install it.');
        return;
      }

      try {
        const response = await provider.connect();
        walletAddress = response.publicKey.toString();
        walletConnected = true;
        
        document.getElementById('wallet-btn').textContent = 
          `✅ ${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}`;
        
        console.log('✅ Wallet connected:', walletAddress);
      } catch (err) {
        console.error('❌ Connection failed:', err);
      }
    }

    document.getElementById('wallet-btn').addEventListener('click', connectWallet);

    // ===== MOUSE EVENTS =====
    function onMouseMove(event) {
      if (!animationStarted) return; // Don't interact before gallery starts
      
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(cubes);

      // Reset previous hover
      if (hoveredCube) {
        hoveredCube.material.emissiveIntensity = 0.3;
        document.getElementById('cube-label').style.display = 'none';
      }

      if (intersects.length > 0) {
        hoveredCube = intersects[0].object;
        hoveredCube.material.emissiveIntensity = 0.8;
          
          // Show label
          const label = document.getElementById('cube-label');
          label.textContent = hoveredCube.userData.isMinted 
            ? `Cube #${hoveredCube.userData.id} - MINTED ✅` 
            : `Cube #${hoveredCube.userData.id} - Click to Mint`;
          label.style.display = 'block';
          label.style.left = event.clientX + 15 + 'px';
          label.style.top = event.clientY + 15 + 'px';
          
          renderer.domElement.style.cursor = 'pointer';
        } else {
          hoveredCube = null;
          renderer.domElement.style.cursor = 'default';
        }
      }
    

    function onMouseClick(event) {
      if (!animationStarted || !hoveredCube) return;

      // If box is minted, show message modal
      if (hoveredCube.userData.isMinted) {
        showMessageModal(hoveredCube);
        return;
      }

      // Otherwise, mint the box
      if (!walletConnected) {
        alert('⚠️ Please connect your wallet first!');
        return;
      }

      mintMysteryBox(hoveredCube);
    }

    // ===== MESSAGE MODAL FUNCTIONS =====
    function showMessageModal(cube) {
      const modal = document.getElementById('messageModal');
      const isOwner = walletConnected && cube.userData.owner === walletAddress;
      
      // Set title
      document.getElementById('messageModalTitle').textContent = 
        isOwner ? (cube.userData.message ? '✏️ Edit Message' : '💬 Add Message') : '👁️ View Message';
      
      // Show/hide elements based on owner status
      const messageDisplay = document.getElementById('messageDisplay');
      const messageEditArea = document.getElementById('messageEditArea');
      const saveBtn = document.getElementById('messageModalSave');
      
      if (isOwner) {
        // Owner can edit
        messageDisplay.style.display = 'none';
        messageEditArea.style.display = 'block';
        saveBtn.style.display = 'block';
        
        const input = document.getElementById('messageInput');
        input.value = cube.userData.message || '';
        updateCharCount();
        
        // Store reference to current cube
        modal.dataset.cubeId = cube.userData.id;
      } else {
        // Others can only view
        messageDisplay.style.display = 'block';
        messageEditArea.style.display = 'none';
        saveBtn.style.display = 'none';
        
        const messageText = document.getElementById('messageText');
        messageText.innerHTML = cube.userData.message 
          ? cube.userData.message 
          : '<em>No message yet.</em>';
      }
      
      modal.classList.add('active');
    }

    function updateCharCount() {
      const input = document.getElementById('messageInput');
      const counter = document.getElementById('messageCharCount');
      counter.textContent = input.value.length;
    }

    document.getElementById('messageInput').addEventListener('input', updateCharCount);

    document.getElementById('messageModalClose').addEventListener('click', () => {
      document.getElementById('messageModal').classList.remove('active');
    });

    document.getElementById('messageModalSave').addEventListener('click', async () => {
      const modal = document.getElementById('messageModal');
      const cubeId = parseInt(modal.dataset.cubeId);
      const cube = cubes.find(c => c.userData.id === cubeId);
      const message = document.getElementById('messageInput').value.trim();
      
      if (!cube) return;
      
      try {
        console.log('💾 Saving message to database...');
        const { error } = await supabase
          .from('minted_boxes')
          .update({ message: message })
          .eq('box_id', cubeId)
          .eq('wallet_address', walletAddress);
        
        if (error) throw error;
        
        // Update local data
        cube.userData.message = message;
        
        console.log('✅ Message saved!');
        alert('✅ Message saved successfully!');
        modal.classList.remove('active');
      } catch (error) {
        console.error('❌ Failed to save message:', error);
        alert('❌ Failed to save message: ' + error.message);
      }
    });

    async function mintMysteryBox(cube) {
      const cubeId = cube.userData.id;
      console.log(`🎲 Opening Mystery Box #${cubeId}...`);

      const provider = getProvider();
      if (!provider?.isConnected) {
        alert('⚠️ Wallet disconnected');
        return;
      }

      try {
        // Send SOL payment
        console.log('💸 Sending 0.001 SOL...');
        const Connection = (await import('@solana/web3.js')).Connection;
        const PublicKey = (await import('@solana/web3.js')).PublicKey;
        const Transaction = (await import('@solana/web3.js')).Transaction;
        const SystemProgram = (await import('@solana/web3.js')).SystemProgram;
        const LAMPORTS_PER_SOL = (await import('@solana/web3.js')).LAMPORTS_PER_SOL;

        const RECEIVER_WALLET = 'Eamw917X8VNmH6xuD6mnR9Z5uyganASWRr4aNUU4tomt';
        const connection = new Connection('https://mainnet.helius-rpc.com/?api-key=b5dce25c-09db-45bd-ba9b-d2e2f16fc841', 'confirmed');

        const transaction = new Transaction().add(
          SystemProgram.transfer({
            fromPubkey: provider.publicKey,
            toPubkey: new PublicKey(RECEIVER_WALLET),
            lamports: Math.floor(0.001 * LAMPORTS_PER_SOL)
          })
        );

        transaction.feePayer = provider.publicKey;
        const { blockhash } = await connection.getLatestBlockhash('confirmed');
        transaction.recentBlockhash = blockhash;

        const signed = await provider.signTransaction(transaction);
        const signature = await connection.sendRawTransaction(signed.serialize(), {
          skipPreflight: false,
          maxRetries: 2
        });

        console.log('✅ Payment sent:', signature);
        console.log('🔗 https://solscan.io/tx/' + signature);

        // Animate cube opening
        revealMysteryBox(cube);

      } catch (error) {
        console.error('❌ Minting failed:', error);
        alert('❌ Payment failed: ' + (error?.message || String(error)));
      }
    }

    function revealMysteryBox(cube) {
      const cubeId = cube.userData.id;
      
      // Mark as minted
      cube.userData.isMinted = true;
      cube.userData.owner = walletAddress;

      // Spin animation
      let spinCount = 0;
      const spinInterval = setInterval(() => {
        cube.rotation.y += 0.3;
        cube.rotation.x += 0.2;
        spinCount++;

        if (spinCount > 30) {
          clearInterval(spinInterval);
          
          // Load and apply mystery image
          textureLoader.load(
            cube.userData.mysteryImage,
            async (texture) => {
              // Replace material with image texture
              cube.material = new THREE.MeshStandardMaterial({
                map: texture,
                metalness: 0.3,
                roughness: 0.5
              });
              
              // Add golden glow
              cube.material.emissive = new THREE.Color(0xffd700);
              cube.material.emissiveIntensity = 0.5;

              // Save to database
              try {
                console.log('💾 Saving to database...');
                const { error } = await supabase.from('minted_boxes').insert([{
                  box_id: cubeId,
                  wallet_address: walletAddress,
                  image_url: cube.userData.mysteryImage,
                  message: null
                }]);

                if (error) throw error;
                console.log('✅ Saved to database!');

                // Show reveal screen with image + message
                showRevealAfterMint(cube);
              } catch (error) {
                console.error('❌ Database save failed:', error);
                showRevealAfterMint(cube);
              }
            },
            undefined,
            (error) => {
              console.error('Failed to load texture:', error);
              // Fallback: just change color to gold
              cube.material.color = new THREE.Color(0xffd700);
              cube.material.emissive = new THREE.Color(0xffd700);
              cube.material.emissiveIntensity = 0.8;
              showRevealAfterMint(cube);
            }
          );
        }
      }, 50);
    }

    function showRevealAfterMint(cube) {
      // Show reveal screen with the minted image
      const revealScreen = document.getElementById('reveal-screen');
      const revealImage = document.getElementById('reveal-image');
      const revealMessage = document.querySelector('.reveal-message');
      
      revealImage.src = cube.userData.mysteryImage;
      
      // Update message with the specific image message
      revealMessage.innerHTML = `
        <h2>🎉 Mystery Box #${cube.userData.id} Opened!</h2>
        <p>${cube.userData.imageMessage}</p>
        <button id="reveal-continue-mint">Continue to Gallery →</button>
      `;
      
      revealScreen.classList.add('active');
      
      // Add event listener to new button
      document.getElementById('reveal-continue-mint').addEventListener('click', () => {
        revealScreen.classList.remove('active');
      }, { once: true });
    }

    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('click', onMouseClick);

    // ===== RESPONSIVE =====
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ===== ANIMATION LOOP =====
    function animate() {
      requestAnimationFrame(animate);

      // Animate cubes - floating motion
      cubes.forEach((cube) => {
        cube.position.y = 
          cube.userData.originalY + 
          Math.sin(Date.now() * 0.001 * cube.userData.speed) * 0.5;
        
        cube.rotation.x += cube.userData.rotSpeed;
        cube.rotation.y += cube.userData.rotSpeed * 0.7;
      });

      // Animate lights
      pointLight1.position.x = Math.sin(Date.now() * 0.001) * 8;
      pointLight1.position.z = Math.cos(Date.now() * 0.001) * 8;
      
      pointLight2.position.x = Math.cos(Date.now() * 0.0015) * 8;
      pointLight2.position.z = Math.sin(Date.now() * 0.0015) * 8;

      controls.update();
      renderer.render(scene, camera);
    }
    
    // Animation will be started by title screen click
  </script>
</body>
</html>
</body>
</html>