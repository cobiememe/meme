<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Cobie Tetris</title>
<style>
  :root{
    --glow: cyan;
    --panel-bg: rgba(20,20,40,.7);
  }
  body{
    margin:0;
    height:100vh;
    display:flex;
    justify-content:center;
    align-items:center;
    background: radial-gradient(circle at 50% 120%, #001020 0%, #000 60%);
    color:#fff; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    overflow:hidden;
  }

  /* Sterne */
  .stars{position:absolute; inset:0; pointer-events:none; z-index:0;}
  .stars span{position:absolute; width:2px; height:2px; background:#fff; border-radius:50%;
    animation:twinkle 2.2s infinite alternate}
  @keyframes twinkle{from{opacity:.3} to{opacity:1}}

  .game-wrap{position:relative; z-index:1; display:flex; gap:44px; align-items:flex-start}

  /* Board */
  #board{
    background:rgba(0,0,0,.9);
    border:4px solid var(--glow);
    box-shadow: 0 0 26px var(--glow), 0 0 52px #09f;
    border-radius:14px;
  }

  /* Sidebar */
  .sidebar{display:flex; flex-direction:column; gap:18px; min-width:220px}
  .panel{
    background:var(--panel-bg);
    border:2px solid rgba(255,255,255,.08);
    border-radius:12px;
    box-shadow:0 0 12px rgba(0,255,255,.25);
    padding:12px 14px;
  }
  .panel h2{
    margin:0 0 8px; text-align:center; font-size:1.2rem;
    color:#ffd400; text-shadow:0 0 10px #ff9900, 0 0 18px #ff4400;
  }
  .stat{font-size:1rem; line-height:1.35}
  .preview{display:block; margin:8px auto 0; background:#000; border:2px solid rgba(255,255,255,.1); border-radius:10px; box-shadow:inset 0 0 12px rgba(0,255,255,.12)}
  #cobieGif{display:block; margin:8px auto 0; width:180px; border:3px solid magenta; border-radius:12px; box-shadow:0 0 22px magenta, 0 0 44px purple}

  /* Achievement Panel */
  .achievement{
    font-size:0.95rem; line-height:1.6; color:#ffd400;
    text-shadow:0 0 8px #ff9900;
    min-height:80px;
  }

  /* Overlay Titelbildschirm */
  #overlay {
    position:absolute; inset:0;
    display:flex; flex-direction:column;
    justify-content:center; align-items:center;
    background:rgba(0,0,0,0.9);
    z-index:5;
  }
  #overlay h1{
    font-size:5em; color:#ffd400;
    text-shadow:0 0 25px #ff9900,0 0 50px #ff4400;
    animation:pulse 2s infinite;
  }
  #pressStart{
    margin-top:20px; font-size:1.6em;
    color:cyan; text-shadow:0 0 12px cyan;
    animation:blink 1.2s infinite;
  }
  @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.2)}100%{transform:scale(1)}}
  @keyframes blink{0%,50%{opacity:1}51%,100%{opacity:0}}

  /* Shake Effekt */
  @keyframes shake {
    0% { transform: translate(0, 0); }
    10% { transform: translate(-8px, 2px) rotate(-1deg); }
    20% { transform: translate(8px, -2px) rotate(1deg); }
    30% { transform: translate(-8px, 2px) rotate(-1deg); }
    40% { transform: translate(8px, -2px) rotate(1deg); }
    50% { transform: translate(-8px, 2px) rotate(-1deg); }
    60% { transform: translate(8px, -2px) rotate(1deg); }
    70% { transform: translate(-4px, 1px) rotate(-0.5deg); }
    80% { transform: translate(4px, -1px) rotate(0.5deg); }
    90% { transform: translate(-2px, 0px); }
    100% { transform: translate(0, 0) rotate(0deg); }
  }
  .shake { animation: shake 0.6s; }

  /* Combo Message */
  .combo-msg{
    position:fixed;
    font-size:4em;
    font-weight:bold;
    color:#fff;
    text-shadow:0 0 20px currentColor, 0 0 40px currentColor;
    pointer-events:none;
    z-index:10;
    animation:comboFade 1.5s ease-out forwards;
  }
  @keyframes comboFade{
    0%{transform:scale(0.5) translateY(50px); opacity:0;}
    20%{transform:scale(1.3) translateY(0); opacity:1;}
    80%{opacity:1;}
    100%{transform:scale(1) translateY(-30px); opacity:0;}
  }

  /* Firework Particles */
  .firework{
    position:fixed;
    width:8px;
    height:8px;
    border-radius:50%;
    pointer-events:none;
    z-index:9;
  }
  @keyframes fireworkAnim{
    0%{transform:translate(0,0) scale(1); opacity:1;}
    100%{transform:translate(var(--tx),var(--ty)) scale(0); opacity:0;}
  }
</style>
</head>
<body>

<!-- Sterne -->
<div class="stars" id="stars"></div>

<!-- Overlay -->
<div id="overlay">
  <h1>COBIE TETRIS</h1>
  <div id="pressStart">Press Enter to Play</div>
</div>

<div class="game-wrap">
  <!-- Board -->
  <canvas id="board" width="440" height="880"></canvas>

  <!-- Sidebar -->
  <div class="sidebar">
    <div class="panel">
      <h2>COBIE TETRIS</h2>
      <div class="stat" id="score">Score: 0</div>
      <div class="stat" id="lines">Lines: 0</div>
      <div class="stat" id="level">Level: 1</div>
    </div>
    <div class="panel">
      <h2>Next</h2>
      <canvas id="next" class="preview" width="160" height="160"></canvas>
    </div>
    <div class="panel">
      <h2>Hold (C)</h2>
      <canvas id="hold" class="preview" width="160" height="160"></canvas>
    </div>
    <div class="panel">
      <h2>Achievement</h2>
      <div class="achievement" id="achievement">Reach 1000 points!</div>
    </div>
    <div class="panel">
      <h2>Cobie</h2>
      <img id="cobieGif" src="../img/cobieGif.gif" alt="Cobie GIF">
    </div>
  </div>
</div>

<script>
/* Sterne erzeugen */
const stars = document.getElementById('stars');
for(let i=0;i<120;i++){
  const s=document.createElement('span');
  s.style.left=Math.random()*100+'%';
  s.style.top=Math.random()*100+'%';
  s.style.animationDuration=(1.8+Math.random()*2.5)+'s';
  stars.appendChild(s);
}

/* Sounds */
const clearSfx = new Audio("../sounds/clear.mp3");
const tetrisSfx = new Audio("../sounds/tetris.mp3");
const bgMusic = new Audio("../sounds/UpOnly.mp3");
bgMusic.loop = true;
bgMusic.volume = 0.3;

/* Setup */
const board=document.getElementById('board');
const ctx=board.getContext('2d');
const nextCtx=document.getElementById('next').getContext('2d');
const holdCtx=document.getElementById('hold').getContext('2d');
const scoreEl=document.getElementById('score');
const linesEl=document.getElementById('lines');
const levelEl=document.getElementById('level');
const achievementEl=document.getElementById('achievement');
const overlay=document.getElementById('overlay');

const rows=20, cols=10, blockSize=44;
board.width=cols*blockSize;
board.height=rows*blockSize;

const colors=[null,"#0ff","#f0f","#ff0","#0f0","#f44","#44f","#fa0"];

function drawBlock(x,y,color,context=ctx,size=blockSize){
  if(!color) return;
  const g=context.createLinearGradient(x,y,x,y+size);
  g.addColorStop(0,"rgba(255,255,255,.95)");
  g.addColorStop(.3,color);
  g.addColorStop(1,"rgba(0,0,0,.85)");
  context.fillStyle=g;
  context.shadowColor=color;
  context.shadowBlur=12;
  context.fillRect(x,y,size-1,size-1);
  context.shadowBlur=0;
  context.strokeStyle="rgba(255,255,255,.12)";
  context.strokeRect(x,y,size-1,size-1);
}

/* Arena */
const arena=Array.from({length:rows},()=>Array(cols).fill(0));

function collide(arena,player){
  const m=player.matrix,o=player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 && ((arena[y+o.y] && arena[y+o.y][x+o.x])!==0)){
        return true;
      }
    }
  }
  return false;
}
function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0) arena[y+player.pos.y][x+player.pos.x]=v;
    });
  });
  canHold=true;
}

/* Achievements */
const achievements = [
  {points: 1000, msg: "You're getting good!"},
  {points: 2500, msg: "Impressive skills!"},
  {points: 5000, msg: "You're a Tetris pro!"},
  {points: 10000, msg: "Legendary player!"},
  {points: 20000, msg: "You are a Tetris Master!"}
];
let currentAchievement = 0;

function checkAchievements(score){
  if(currentAchievement < achievements.length && score >= achievements[currentAchievement].points){
    achievementEl.textContent = achievements[currentAchievement].msg;
    currentAchievement++;
  }
}

/* Combo Messages */
function showComboMsg(lines){
  let msg = '', color = '#fff';
  if(lines === 2) { msg = 'Good!'; color = '#0f0'; }
  else if(lines === 3) { msg = 'Awesome!'; color = '#f0f'; }
  else if(lines === 4) { msg = 'Phenomenal!'; color = '#ff0'; }
  else return;

  const el = document.createElement('div');
  el.className = 'combo-msg';
  el.textContent = msg;
  el.style.color = color;
  el.style.left = Math.random() > 0.5 ? '10%' : '85%';
  el.style.top = '50%';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 1500);
}

/* Fireworks */
function createFirework(x, y){
  for(let i=0; i<30; i++){
    const particle = document.createElement('div');
    particle.className = 'firework';
    const colors = ['#ff0', '#f0f', '#0ff', '#f00', '#0f0'];
    particle.style.background = colors[Math.floor(Math.random()*colors.length)];
    particle.style.left = x + 'px';
    particle.style.top = y + 'px';
    
    const angle = (Math.PI * 2 * i) / 30;
    const velocity = 100 + Math.random() * 100;
    const tx = Math.cos(angle) * velocity;
    const ty = Math.sin(angle) * velocity;
    
    particle.style.setProperty('--tx', tx + 'px');
    particle.style.setProperty('--ty', ty + 'px');
    particle.style.animation = 'fireworkAnim 1s ease-out forwards';
    
    document.body.appendChild(particle);
    setTimeout(() => particle.remove(), 1000);
  }
}

/* Effekte */
let clearingRows=[];

function arenaSweep(){
  let rowsToClear=[];
  outer: for(let y=arena.length-1;y>=0;--y){
    for(let x=0;x<cols;x++){ if(arena[y][x]===0) continue outer; }
    rowsToClear.push(y);
  }
  if(rowsToClear.length){
    clearingRows=rowsToClear.map(r=>({row:r,frames:0}));
    
    // Combo Messages
    showComboMsg(rowsToClear.length);
    
    if(rowsToClear.length===4){
      tetrisSfx.currentTime=0; tetrisSfx.play();
      board.classList.add("shake");
      setTimeout(()=>board.classList.remove("shake"),600);
      
      // Fireworks
      setTimeout(() => {
        createFirework(window.innerWidth * 0.15, window.innerHeight * 0.3);
        createFirework(window.innerWidth * 0.85, window.innerHeight * 0.3);
        createFirework(window.innerWidth * 0.15, window.innerHeight * 0.7);
        createFirework(window.innerWidth * 0.85, window.innerHeight * 0.7);
      }, 100);
    } else {
      clearSfx.currentTime=0; clearSfx.play();
    }
    
    player.score += [0,100,300,500,800][rowsToClear.length];
    player.lines += rowsToClear.length;
    checkAchievements(player.score);
    const level=Math.floor(player.lines/10)+1;
    scoreEl.textContent=`Score: ${player.score}`;
    linesEl.textContent=`Lines: ${player.lines}`;
    levelEl.textContent=`Level: ${level}`;
    dropInterval=Math.max(120,1000-(level-1)*70);
  }
}

/* Pieces */
function createPiece(type){
  if(type==='T') return [[0,0,0],[1,1,1],[0,1,0]];
  if(type==='O') return [[2,2],[2,2]];
  if(type==='L') return [[0,3,0],[0,3,0],[0,3,3]];
  if(type==='J') return [[0,4,0],[0,4,0],[4,4,0]];
  if(type==='I') return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
  if(type==='S') return [[0,6,6],[6,6,0],[0,0,0]];
  if(type==='Z') return [[7,7,0],[0,7,7],[0,0,0]];
}
function randomType(){ const bag='TJLOSZI'; return bag[bag.length*Math.random()|0]; }
let nextType=randomType(), holdType=null, canHold=true;

/* Player */
const player={pos:{x:0,y:0},matrix:null,score:0,lines:0,type:null};
function playerReset(fromHold=false){
  const type=fromHold?player.type:nextType;
  if(!fromHold) nextType=randomType();
  player.type=type;
  player.matrix=createPiece(type);
  player.pos.y=0;
  player.pos.x=(cols/2|0)-(player.matrix[0].length/2|0);
  drawNext();
  if(collide(arena,player)){
    arena.forEach(r=>r.fill(0));
    player.score=0;player.lines=0;
    currentAchievement=0;
    achievementEl.textContent="Reach 1000 points!";
    scoreEl.textContent='Score: 0';
    linesEl.textContent='Lines: 0';
    levelEl.textContent='Level: 1';
    dropInterval=1000;
  }
}
function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    arenaSweep();
    playerReset();
  }
  dropCounter=0;
}
function playerMove(d){player.pos.x+=d;if(collide(arena,player))player.pos.x-=d;}
function playerRotate(){
  const m=player.matrix;
  for(let y=0;y<m.length;y++) for(let x=0;x<y;x++) [m[x][y],m[y][x]]=[m[y][x],m[x][y]];
  m.forEach(r=>r.reverse());
  if(collide(arena,player)){player.pos.x++;if(collide(arena,player))player.pos.x-=2;}
}
function playerHardDrop(){
  while(!collide(arena,player)) player.pos.y++;
  player.pos.y--; merge(arena,player); arenaSweep(); playerReset(); dropCounter=0;
}
function holdSwap(){
  if(!canHold) return;
  if(holdType==null){ holdType=player.type; drawHold(); playerReset(); }
  else{ const tmp=holdType; holdType=player.type; drawHold(); player.type=tmp; player.matrix=createPiece(tmp); player.pos.y=0; player.pos.x=(cols/2|0)-(player.matrix[0].length/2|0); }
  canHold=false;
}

/* Draw */
function drawMatrix(matrix,offset,context=ctx,size=blockSize){
  matrix.forEach((row,y)=>row.forEach((v,x)=>{ if(v!==0) drawBlock((x+offset.x)*size,(y+offset.y)*size,colors[v],context,size); }));
}
function drawNext(){
  nextCtx.clearRect(0,0,160,160);
  const m=createPiece(nextType);
  const offX=Math.max(0,3-(m[0].length>>1));
  drawMatrix(m,{x:offX,y:1},nextCtx,28);
}
function drawHold(){
  holdCtx.clearRect(0,0,160,160);
  if(!holdType) return;
  const m=createPiece(holdType);
  const offX=Math.max(0,3-(m[0].length>>1));
  drawMatrix(m,{x:offX,y:1},holdCtx,28);
}

/* Render Loop mit Blink */
let dropCounter=0,lastTime=0,dropInterval=1000;
function draw(){
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,board.width,board.height);
  for(let y=0;y<arena.length;y++){
    for(let x=0;x<arena[y].length;x++){
      const v=arena[y][x];
      if(v!==0){
        const eff=clearingRows.find(r=>r.row===y);
        if(eff){
          const phase=eff.frames%10;
          ctx.globalAlpha=phase<5?1:0.2;
          let size=blockSize*(1+eff.frames/30);
          let offset=(size-blockSize)/2;
          drawBlock(x*blockSize-offset,y*blockSize-offset,colors[v],ctx,size);
          ctx.globalAlpha=1;
        } else drawBlock(x*blockSize,y*blockSize,colors[v]);
      }
    }
  }
  drawMatrix(player.matrix,player.pos);
  if(clearingRows.length){
    clearingRows.forEach(r=>r.frames++);
    if(clearingRows[0].frames>20){
      clearingRows.forEach(r=>{arena.splice(r.row,1);arena.unshift(Array(cols).fill(0));});
      clearingRows=[];
    }
  }
}
function update(t=0){
  const dt=t-lastTime; lastTime=t; dropCounter+=dt;
  if(dropCounter>dropInterval) playerDrop();
  draw(); requestAnimationFrame(update);
}

/* Controls */
document.addEventListener('keydown',e=>{
  if(overlay.style.display!=='none' && e.code==='Enter'){
    overlay.style.display='none';
    playerReset();
    bgMusic.play().catch(err => console.log('Audio play failed:', err));
    update();
  }
  if(overlay.style.display!=='none') return;
  if(e.code==='ArrowLeft')playerMove(-1);
  else if(e.code==='ArrowRight')playerMove(1);
  else if(e.code==='ArrowDown')playerDrop();
  else if(e.code==='ArrowUp')playerRotate();
  else if(e.code==='Space'){e.preventDefault();playerHardDrop();}
  else if(e.code==='KeyC')holdSwap();
});

/* Start */
playerReset(); drawNext(); drawHold();
</script>
</body>
</html>