<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cobie Tetris Effect</title>
<style>
  :root{
    --glow: cyan;
    --panel-bg: rgba(20,20,40,.7);
  }
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    justify-content:center;
    align-items:center;
    background: radial-gradient(circle at 50% 120%, #001020 0%, #000 60%);
    color:#fff; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    overflow:hidden;
    padding:20px 10px;
    box-sizing:border-box;
  }

  /* Sterne */
  .stars{position:absolute; inset:0; pointer-events:none; z-index:0;}
  .stars span{position:absolute; width:2px; height:2px; background:#fff; border-radius:50%;
    animation:twinkle 2.2s infinite alternate}
  @keyframes twinkle{from{opacity:.3} to{opacity:1}}

  /* Particle Canvas */
  #particles{
    position:fixed;
    inset:0;
    pointer-events:none;
    z-index:2;
  }

  /* Light Beams - SICHTBARER */
  .light-beam{
    position:fixed;
    width:100%;
    height:8px;
    background:linear-gradient(90deg, transparent, rgba(0,255,255,0.6) 30%, rgba(0,150,255,0.8) 50%, rgba(0,255,255,0.6) 70%, transparent);
    pointer-events:none;
    z-index:1;
    filter:blur(4px);
    animation:beamMove 4s infinite;
    box-shadow:0 0 30px rgba(0,255,255,0.8);
  }
  @keyframes beamMove{
    0%{transform:translateX(-150%); opacity:0;}
    10%{opacity:1;}
    90%{opacity:1;}
    100%{transform:translateX(150%); opacity:0;}
  }

  /* Pulsing Glow Around Board */
  @keyframes boardPulse{
    0%, 100%{filter:drop-shadow(0 0 20px rgba(0,255,255,0.4));}
    50%{filter:drop-shadow(0 0 40px rgba(0,255,255,0.8));}
  }

  .game-wrap{
    position:relative; 
    z-index:3; 
    display:flex; 
    gap:20px; 
    align-items:flex-start;
    max-height:90vh;
    transform:scale(0.85);
    transform-origin:center center;
    animation:boardPulse 3s infinite ease-in-out;
  }

  /* Board with Glow */
  #board{
    background:rgba(0,0,0,.9);
    border:4px solid var(--glow);
    box-shadow: 
      0 0 30px var(--glow), 
      0 0 60px #09f,
      0 0 90px rgba(0,255,255,0.5),
      inset 0 0 80px rgba(0,255,255,0.15);
    border-radius:14px;
    position:relative;
  }

  /* Sidebar */
  .sidebar{display:flex; flex-direction:column; gap:14px; min-width:200px; max-width:220px;}
  .panel{
    background:var(--panel-bg);
    border:2px solid rgba(255,255,255,.08);
    border-radius:12px;
    box-shadow:0 0 12px rgba(0,255,255,.25);
    padding:10px 12px;
  }
  .panel h2{
    margin:0 0 6px; text-align:center; font-size:1.1rem;
    color:#ffd400; text-shadow:0 0 10px #ff9900, 0 0 18px #ff4400;
  }
  .stat{font-size:0.95rem; line-height:1.35}
  .preview{display:block; margin:6px auto 0; background:#000; border:2px solid rgba(255,255,255,.1); border-radius:10px; box-shadow:inset 0 0 12px rgba(0,255,255,.12)}
  #cobieGif{display:block; margin:6px auto 0; width:160px; border:3px solid magenta; border-radius:12px; box-shadow:0 0 22px magenta, 0 0 44px purple}

  /* Achievement Panel */
  .achievement{
    font-size:0.9rem; 
    line-height:1.5; 
    color:#ffd400;
    text-shadow:0 0 8px #ff9900;
    min-height:100px;
    max-height:180px;
    overflow-y:auto;
  }
  .achievement div{
    margin-bottom:8px;
    padding:4px;
    background:rgba(255,215,0,0.1);
    border-radius:4px;
    animation:achieveGlow 0.5s ease-out;
  }
  @keyframes achieveGlow{
    0%{transform:scale(0.8); opacity:0; background:rgba(255,215,0,0.4);}
    100%{transform:scale(1); opacity:1; background:rgba(255,215,0,0.1);}
  }

  /* Overlay Titelbildschirm */
  #overlay {
    position:absolute; inset:0;
    display:flex; flex-direction:column;
    justify-content:center; align-items:center;
    background:rgba(0,0,0,0.9);
    z-index:5;
  }
  #overlay h1{
    font-size:4em; color:#ffd400;
    text-shadow:0 0 25px #ff9900,0 0 50px #ff4400;
    animation:pulse 2s infinite;
  }
  #pressStart{
    margin-top:20px; font-size:1.4em;
    color:cyan; text-shadow:0 0 12px cyan;
    animation:blink 1.2s infinite;
  }
  @keyframes pulse{0%{transform:scale(1)}50%{transform:scale(1.2)}100%{transform:scale(1)}}
  @keyframes blink{0%,50%{opacity:1}51%,100%{opacity:0}}

  /* Shake Effekt - LÃ„NGER */
  @keyframes shake {
    0% { transform: translate(0, 0) rotate(0); }
    5% { transform: translate(-10px, 3px) rotate(-2deg); }
    10% { transform: translate(10px, -3px) rotate(2deg); }
    15% { transform: translate(-10px, 3px) rotate(-2deg); }
    20% { transform: translate(10px, -3px) rotate(2deg); }
    25% { transform: translate(-10px, 3px) rotate(-2deg); }
    30% { transform: translate(10px, -3px) rotate(2deg); }
    35% { transform: translate(-8px, 2px) rotate(-1.5deg); }
    40% { transform: translate(8px, -2px) rotate(1.5deg); }
    45% { transform: translate(-8px, 2px) rotate(-1.5deg); }
    50% { transform: translate(8px, -2px) rotate(1.5deg); }
    55% { transform: translate(-6px, 1px) rotate(-1deg); }
    60% { transform: translate(6px, -1px) rotate(1deg); }
    65% { transform: translate(-6px, 1px) rotate(-1deg); }
    70% { transform: translate(6px, -1px) rotate(1deg); }
    75% { transform: translate(-4px, 0.5px) rotate(-0.5deg); }
    80% { transform: translate(4px, -0.5px) rotate(0.5deg); }
    85% { transform: translate(-2px, 0px) rotate(-0.2deg); }
    90% { transform: translate(2px, 0px) rotate(0.2deg); }
    95% { transform: translate(-1px, 0px); }
    100% { transform: translate(0, 0) rotate(0deg); }
  }
  .shake { animation: shake 1.5s; }

  /* Combo Message */
  .combo-msg{
    position:fixed;
    font-size:4em;
    font-weight:bold;
    color:#fff;
    text-shadow:0 0 20px currentColor, 0 0 40px currentColor;
    pointer-events:none;
    z-index:10;
    animation:comboFade 2s ease-out forwards;
  }
  @keyframes comboFade{
    0%{transform:scale(0.5) translateY(50px); opacity:0;}
    15%{transform:scale(1.4) translateY(0); opacity:1;}
    85%{opacity:1;}
    100%{transform:scale(1) translateY(-30px); opacity:0;}
  }

  /* Responsive */
  @media (max-height: 900px) {
    .game-wrap { transform:scale(0.75); }
  }
  @media (max-height: 750px) {
    .game-wrap { transform:scale(0.65); }
  }
</style>
</head>
<body>

<!-- Sterne -->
<div class="stars" id="stars"></div>

<!-- Particle Canvas -->
<canvas id="particles"></canvas>

<!-- Light Beams Container -->
<div id="beamContainer"></div>

<!-- Overlay -->
<div id="overlay">
  <h1>COBIE TETRIS</h1>
  <div id="pressStart">Press Enter to Play</div>
</div>

<div class="game-wrap">
  <!-- Board -->
  <canvas id="board" width="440" height="880"></canvas>

  <!-- Sidebar -->
  <div class="sidebar">
    <div class="panel">
      <h2>COBIE TETRIS</h2>
      <div class="stat" id="score">Score: 0</div>
      <div class="stat" id="lines">Lines: 0</div>
      <div class="stat" id="level">Level: 1</div>
    </div>
    <div class="panel">
      <h2>Next</h2>
      <canvas id="next" class="preview" width="160" height="160"></canvas>
    </div>
    <div class="panel">
      <h2>Hold (C)</h2>
      <canvas id="hold" class="preview" width="160" height="160"></canvas>
    </div>
    <div class="panel">
      <h2>Achievement</h2>
      <div class="achievement" id="achievement">
        <div style="opacity:0.5;">ðŸŽ¯ Reach 1000 points!</div>
      </div>
    </div>
    <div class="panel">
      <h2>Cobie</h2>
      <img id="cobieGif" src="../img/cobieGif.gif" alt="Cobie GIF">
    </div>
  </div>
</div>

<script>
/* Sterne erzeugen */
const stars = document.getElementById('stars');
for(let i=0;i<120;i++){
  const s=document.createElement('span');
  s.style.left=Math.random()*100+'%';
  s.style.top=Math.random()*100+'%';
  s.style.animationDuration=(1.8+Math.random()*2.5)+'s';
  stars.appendChild(s);
}

/* Light Beams - MEHR UND SICHTBARER */
const beamContainer = document.getElementById('beamContainer');
function createLightBeam(){
  const beam = document.createElement('div');
  beam.className = 'light-beam';
  beam.style.top = (20 + Math.random() * 60) + '%';
  beam.style.left = '0';
  beam.style.animationDuration = (3 + Math.random() * 2) + 's';
  beam.style.animationDelay = Math.random() * 1 + 's';
  beamContainer.appendChild(beam);
  setTimeout(() => beam.remove(), 8000);
}
// Mehr Beams erstellen
setInterval(createLightBeam, 1200);
for(let i=0; i<3; i++) setTimeout(createLightBeam, i * 400);

/* Particle System */
const particleCanvas = document.getElementById('particles');
const pCtx = particleCanvas.getContext('2d');
particleCanvas.width = window.innerWidth;
particleCanvas.height = window.innerHeight;

class Particle {
  constructor(x, y, color, vx, vy, size = 2, life = 100) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.vx = vx;
    this.vy = vy;
    this.size = size;
    this.life = life;
    this.maxLife = life;
    this.alpha = 1;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.08; // gravity
    this.life--;
    this.alpha = this.life / this.maxLife;
  }
  
  draw() {
    pCtx.globalAlpha = this.alpha;
    pCtx.fillStyle = this.color;
    pCtx.shadowBlur = 20;
    pCtx.shadowColor = this.color;
    pCtx.beginPath();
    pCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
    pCtx.fill();
    pCtx.shadowBlur = 0;
  }
}

let particles = [];
let backgroundParticles = [];

// Background ambient particles
for(let i = 0; i < 60; i++) {
  backgroundParticles.push({
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    size: Math.random() * 4 + 1,
    vx: (Math.random() - 0.5) * 0.7,
    vy: (Math.random() - 0.5) * 0.7,
    color: ['#0ff', '#09f', '#06f', '#0af'][Math.floor(Math.random() * 4)]
  });
}

function updateParticles() {
  pCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
  
  // Background particles
  backgroundParticles.forEach(p => {
    p.x += p.vx;
    p.y += p.vy;
    if(p.x < 0) p.x = window.innerWidth;
    if(p.x > window.innerWidth) p.x = 0;
    if(p.y < 0) p.y = window.innerHeight;
    if(p.y > window.innerHeight) p.y = 0;
    
    pCtx.globalAlpha = 0.7;
    pCtx.fillStyle = p.color;
    pCtx.shadowBlur = 15;
    pCtx.shadowColor = p.color;
    pCtx.beginPath();
    pCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    pCtx.fill();
  });
  
  // Active particles
  particles = particles.filter(p => p.life > 0);
  particles.forEach(p => {
    p.update();
    p.draw();
  });
  
  pCtx.globalAlpha = 1;
  pCtx.shadowBlur = 0;
}

function createParticleBurst(x, y, count, color) {
  for(let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 * i) / count;
    const speed = 2 + Math.random() * 4;
    particles.push(new Particle(
      x, y, color,
      Math.cos(angle) * speed,
      Math.sin(angle) * speed,
      2.5 + Math.random() * 2,
      80 + Math.random() * 60
    ));
  }
}

function createTrailParticles(x, y, color) {
  for(let i = 0; i < 3; i++) {
    particles.push(new Particle(
      x + (Math.random() - 0.5) * 20,
      y + (Math.random() - 0.5) * 20,
      color,
      (Math.random() - 0.5) * 2,
      (Math.random() - 0.5) * 2,
      1.5 + Math.random(),
      40 + Math.random() * 30
    ));
  }
}

/* Sounds */
const clearSfx = new Audio("../sounds/clear.mp3");
const tetrisSfx = new Audio("../sounds/tetris.mp3");
const bgMusic = new Audio("../sounds/UpOnly.mp3");
bgMusic.loop = true;
bgMusic.volume = 0.3;

/* Setup */
const board=document.getElementById('board');
const ctx=board.getContext('2d');
const nextCtx=document.getElementById('next').getContext('2d');
const holdCtx=document.getElementById('hold').getContext('2d');
const scoreEl=document.getElementById('score');
const linesEl=document.getElementById('lines');
const levelEl=document.getElementById('level');
const achievementEl=document.getElementById('achievement');
const overlay=document.getElementById('overlay');

const rows=20, cols=10, blockSize=44;
board.width=cols*blockSize;
board.height=rows*blockSize;

const boardRect = board.getBoundingClientRect();

const colors=[null,"#0ff","#f0f","#ff0","#0f0","#f44","#44f","#fa0"];

function drawBlock(x,y,color,context=ctx,size=blockSize){
  if(!color) return;
  const g=context.createLinearGradient(x,y,x,y+size);
  g.addColorStop(0,"rgba(255,255,255,.95)");
  g.addColorStop(.3,color);
  g.addColorStop(1,"rgba(0,0,0,.85)");
  context.fillStyle=g;
  context.shadowColor=color;
  context.shadowBlur=18;
  context.fillRect(x,y,size-1,size-1);
  context.shadowBlur=0;
  context.strokeStyle="rgba(255,255,255,.25)";
  context.lineWidth=2;
  context.strokeRect(x,y,size-1,size-1);
}

/* Arena */
const arena=Array.from({length:rows},()=>Array(cols).fill(0));

function collide(arena,player){
  const m=player.matrix,o=player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 && ((arena[y+o.y] && arena[y+o.y][x+o.x])!==0)){
        return true;
      }
    }
  }
  return false;
}
function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0) arena[y+player.pos.y][x+player.pos.x]=v;
    });
  });
  canHold=true;
}

/* Achievements */
const achievements = [
  {points: 1000, msg: "You're getting good!"},
  {points: 2500, msg: "LTC LYtUCVd78LWQkyPe8ah2fkfG5TPigvWDzT"},
  {points: 5000, msg: "You're a Tetris pro!"},
  {points: 10000, msg: "Legendary player! 6vz3EvqANQBtGnU9UFPtESwfwYS"},
  {points: 20000, msg: "Tetris Master! Bmnebr3R9wCV8CzDFRxXvwVY "}
];
let achievedMessages = [];

function checkAchievements(score){
  achievements.forEach((ach, idx) => {
    if(score >= ach.points && !achievedMessages.includes(idx)){
      achievedMessages.push(idx);
      updateAchievementDisplay();
    }
  });
}

function updateAchievementDisplay(){
  if(achievedMessages.length === 0){
    achievementEl.innerHTML = '<div style="opacity:0.5;">ðŸŽ¯ Reach 1000 points!</div>';
    return;
  }
  
  let html = '';
  achievedMessages.forEach(idx => {
    html += `<div>âœ¨ ${achievements[idx].msg}</div>`;
  });
  achievementEl.innerHTML = html;
}

/* Speed basierend auf Punkten */
function calculateDropInterval(score) {
  let baseSpeed = 1000;
  
  if(score >= 15000) baseSpeed *= 0.6; // -40% bei 15k
  else if(score >= 10000) baseSpeed *= 0.7; // -30% bei 10k
  else if(score >= 5000) baseSpeed *= 0.8; // -20% bei 5k
  else if(score >= 2000) baseSpeed *= 0.9; // -10% bei 2k
  
  // ZusÃ¤tzlich Level-basierte Beschleunigung
  const level = Math.floor(player.lines / 10) + 1;
  baseSpeed = Math.max(100, baseSpeed - (level - 1) * 40);
  
  return baseSpeed;
}

/* Combo Messages */
function showComboMsg(lines){
  let msg = '', color = '#fff';
  if(lines === 2) { msg = 'Good!'; color = '#0f0'; }
  else if(lines === 3) { msg = 'Awesome!'; color = '#f0f'; }
  else if(lines === 4) { msg = 'Phenomenal!'; color = '#ff0'; }
  else return;

  const el = document.createElement('div');
  el.className = 'combo-msg';
  el.textContent = msg;
  el.style.color = color;
  el.style.left = Math.random() > 0.5 ? '10%' : '85%';
  el.style.top = '50%';
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 2000);
}

/* Effekte */
let clearingRows=[];

function arenaSweep(){
  let rowsToClear=[];
  outer: for(let y=arena.length-1;y>=0;--y){
    for(let x=0;x<cols;x++){ if(arena[y][x]===0) continue outer; }
    rowsToClear.push(y);
  }
  if(rowsToClear.length){
    clearingRows=rowsToClear.map(r=>({row:r,frames:0}));
    
    // Particle burst for cleared rows
    rowsToClear.forEach(row => {
      for(let x = 0; x < cols; x++) {
        const worldX = boardRect.left + x * blockSize + blockSize/2;
        const worldY = boardRect.top + row * blockSize + blockSize/2;
        createParticleBurst(worldX, worldY, 10, colors[arena[row][x]]);
      }
    });
    
    showComboMsg(rowsToClear.length);
    
    if(rowsToClear.length===4){
      tetrisSfx.currentTime=0; tetrisSfx.play();
      board.classList.add("shake");
      setTimeout(()=>board.classList.remove("shake"),1500);
      
      // MASSIVE particle explosion - LÃ„NGER
      for(let i = 0; i < 150; i++) {
        setTimeout(() => {
          const x = boardRect.left + boardRect.width/2 + (Math.random()-0.5)*300;
          const y = boardRect.top + boardRect.height/2 + (Math.random()-0.5)*300;
          particles.push(new Particle(
            x, y,
            ['#ff0','#f0f','#0ff','#f00','#0f0'][Math.floor(Math.random()*5)],
            (Math.random()-0.5)*10,
            (Math.random()-0.5)*10,
            3+Math.random()*4,
            100+Math.random()*60
          ));
        }, i * 8);
      }
    } else {
      clearSfx.currentTime=0; clearSfx.play();
    }
    
    player.score += [0,100,300,500,800][rowsToClear.length];
    player.lines += rowsToClear.length;
    checkAchievements(player.score);
    const level=Math.floor(player.lines/10)+1;
    scoreEl.textContent=`Score: ${player.score}`;
    linesEl.textContent=`Lines: ${player.lines}`;
    levelEl.textContent=`Level: ${level}`;
    dropInterval = calculateDropInterval(player.score);
  }
}

/* Pieces */
function createPiece(type){
  if(type==='T') return [[0,0,0],[1,1,1],[0,1,0]];
  if(type==='O') return [[2,2],[2,2]];
  if(type==='L') return [[0,3,0],[0,3,0],[0,3,3]];
  if(type==='J') return [[0,4,0],[0,4,0],[4,4,0]];
  if(type==='I') return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
  if(type==='S') return [[0,6,6],[6,6,0],[0,0,0]];
  if(type==='Z') return [[7,7,0],[0,7,7],[0,0,0]];
}
function randomType(){ const bag='TJLOSZI'; return bag[bag.length*Math.random()|0]; }
let nextType=randomType(), holdType=null, canHold=true;

/* Player */
const player={pos:{x:0,y:0},matrix:null,score:0,lines:0,type:null};
function playerReset(fromHold=false){
  const type=fromHold?player.type:nextType;
  if(!fromHold) nextType=randomType();
  player.type=type;
  player.matrix=createPiece(type);
  player.pos.y=0;
  player.pos.x=(cols/2|0)-(player.matrix[0].length/2|0);
  drawNext();
  if(collide(arena,player)){
    arena.forEach(r=>r.fill(0));
    player.score=0;player.lines=0;
    achievedMessages=[];
    updateAchievementDisplay();
    scoreEl.textContent='Score: 0';
    linesEl.textContent='Lines: 0';
    levelEl.textContent='Level: 1';
    dropInterval=1000;
  }
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena,player)){
    player.pos.y--;
    merge(arena,player);
    arenaSweep();
    playerReset();
  } else {
    // Create trail particles
    const m = player.matrix;
    for(let y=0; y<m.length; y++){
      for(let x=0; x<m[y].length; x++){
        if(m[y][x] !== 0) {
          const worldX = boardRect.left + (x + player.pos.x) * blockSize + blockSize/2;
          const worldY = boardRect.top + (y + player.pos.y) * blockSize + blockSize/2;
          if(Math.random() > 0.6) {
            createTrailParticles(worldX, worldY, colors[m[y][x]]);
          }
        }
      }
    }
  }
  dropCounter=0;
}

function playerMove(d){
  player.pos.x+=d;
  if(collide(arena,player))player.pos.x-=d;
}

function playerRotate(){
  const m=player.matrix;
  for(let y=0;y<m.length;y++) for(let x=0;x<y;x++) [m[x][y],m[y][x]]=[m[y][x],m[x][y]];
  m.forEach(r=>r.reverse());
  if(collide(arena,player)){player.pos.x++;if(collide(arena,player))player.pos.x-=2;}
  
  // Rotation particle effect
  const centerX = boardRect.left + (player.pos.x + m[0].length/2) * blockSize;
  const centerY = boardRect.top + (player.pos.y + m.length/2) * blockSize;
  for(let i=0; i<15; i++){
    const angle = (Math.PI * 2 * i) / 15;
    particles.push(new Particle(
      centerX, centerY,
      colors[m[0].find(v => v !== 0) || 1],
      Math.cos(angle) * 4,
      Math.sin(angle) * 4,
      2.5, 40
    ));
  }
}

function playerHardDrop(){
  while(!collide(arena,player)) player.pos.y++;
  player.pos.y--; 
  
  // Hard drop particles
  const m = player.matrix;
  for(let y=0; y<m.length; y++){
    for(let x=0; x<m[y].length; x++){
      if(m[y][x] !== 0) {
        const worldX = boardRect.left + (x + player.pos.x) * blockSize + blockSize/2;
        const worldY = boardRect.top + (y + player.pos.y) * blockSize + blockSize/2;
        createParticleBurst(worldX, worldY, 15, colors[m[y][x]]);
      }
    }
  }
  
  merge(arena,player); arenaSweep(); playerReset(); dropCounter=0;
}

function holdSwap(){
  if(!canHold) return;
  if(holdType==null){ holdType=player.type; drawHold(); playerReset(); }
  else{ const tmp=holdType; holdType=player.type; drawHold(); player.type=tmp; player.matrix=createPiece(tmp); player.pos.y=0; player.pos.x=(cols/2|0)-(player.matrix[0].length/2|0); }
  canHold=false;
}

/* Draw */
function drawMatrix(matrix,offset,context=ctx,size=blockSize){
  matrix.forEach((row,y)=>row.forEach((v,x)=>{ if(v!==0) drawBlock((x+offset.x)*size,(y+offset.y)*size,colors[v],context,size); }));
}
function drawNext(){
  nextCtx.clearRect(0,0,160,160);
  const m=createPiece(nextType);
  const offX=Math.max(0,3-(m[0].length>>1));
  drawMatrix(m,{x:offX,y:1},nextCtx,28);
}
function drawHold(){
  holdCtx.clearRect(0,0,160,160);
  if(!holdType) return;
  const m=createPiece(holdType);
  const offX=Math.max(0,3-(m[0].length>>1));
  drawMatrix(m,{x:offX,y:1},holdCtx,28);
}

/* Render Loop */
let dropCounter=0,lastTime=0,dropInterval=1000;
function draw(){
  ctx.fillStyle="#000";
  ctx.fillRect(0,0,board.width,board.height);
  
  // Draw glow effect around board edges
  ctx.shadowBlur = 25;
  ctx.shadowColor = 'rgba(0,255,255,0.4)';
  ctx.strokeStyle = 'rgba(0,255,255,0.15)';
  ctx.lineWidth = 6;
  ctx.strokeRect(3, 3, board.width-6, board.height-6);
  ctx.shadowBlur = 0;
  
  for(let y=0;y<arena.length;y++){
    for(let x=0;x<arena[y].length;x++){
      const v=arena[y][x];
      if(v!==0){
        const eff=clearingRows.find(r=>r.row===y);
        if(eff){
          const phase=eff.frames%10;
          ctx.globalAlpha=phase<5?1:0.3;
          let size=blockSize*(1+eff.frames/25);
          let offset=(size-blockSize)/2;
          drawBlock(x*blockSize-offset,y*blockSize-offset,colors[v],ctx,size);
          ctx.globalAlpha=1;
        } else drawBlock(x*blockSize,y*blockSize,colors[v]);
      }
    }
  }
  drawMatrix(player.matrix,player.pos);
  if(clearingRows.length){
    clearingRows.forEach(r=>r.frames++);
    if(clearingRows[0].frames>25){
      clearingRows.forEach(r=>{arena.splice(r.row,1);arena.unshift(Array(cols).fill(0));});
      clearingRows=[];
    }
  }
}
function update(t=0){
  const dt=t-lastTime; lastTime=t; dropCounter+=dt;
  if(dropCounter>dropInterval) playerDrop();
  draw(); 
  updateParticles();
  requestAnimationFrame(update);
}

/* Controls */
document.addEventListener('keydown',e=>{
  if(overlay.style.display!=='none' && e.code==='Enter'){
    overlay.style.display='none';
    playerReset();
    bgMusic.play().catch(err => console.log('Audio play failed:', err));
    update();
  }
  if(overlay.style.display!=='none') return;
  if(e.code==='ArrowLeft')playerMove(-1);
  else if(e.code==='ArrowRight')playerMove(1);
  else if(e.code==='ArrowDown')playerDrop();
  else if(e.code==='ArrowUp')playerRotate();
  else if(e.code==='Space'){e.preventDefault();playerHardDrop();}
  else if(e.code==='KeyC')holdSwap();
});

/* Start */
playerReset(); drawNext(); drawHold();
</script>
</body>
</html>