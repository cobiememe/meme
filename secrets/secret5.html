<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Secret 4 â€” Meme Invaders (Deluxe)</title>
  <style>
    body {
      margin: 0;
      background: radial-gradient(circle at bottom, #001, #000 70%);
      overflow: hidden;
      color: #fff;
      font-family: monospace;
      text-align: center;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: rgba(0,0,0,0.85);
      border: 3px solid cyan;
      box-shadow: 0 0 25px cyan, 0 0 50px #09f;
    }

    /* Overlay / Intro */
    #overlay {
      position: absolute; inset: 0;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      background: rgba(0,0,0,0.92);
      z-index: 10;
    }
    #overlay h1 {
      font-size: 4em;
      color: #ffd400;
      text-shadow: 0 0 20px #ff9900, 0 0 40px #ff4400;
      animation: titlePulse 2s infinite;
    }
    @keyframes titlePulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    #pressStart {
      margin-top: 18px;
      font-size: 1.5em;
      color: #0ff;
      text-shadow: 0 0 12px #0ff;
      animation: blink 1.1s infinite;
    }
    @keyframes blink { 0%,50%{opacity:1} 51%,100%{opacity:0} }

    /* HUD */
    #scoreBoard {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      font-size: 1.1em; color: #0ff; text-shadow: 0 0 10px #0ff;
    }
    #waveBoard {
      position: absolute; top: 10px; right: 18px;
      font-size: 1.1em; color: #ffd400; text-shadow: 0 0 10px #ff9900;
    }
    #bossHP {
      position: absolute; top: 120px; right: 10px;
      writing-mode: vertical-rl;
      font-size: 1.2em;
      color: #f0f;
      text-shadow: 0 0 12px #f0f, 0 0 20px #c0f;
      display: none; z-index: 2;
    }

    /* Game Over */
    #gameOver {
      position: absolute; inset: 0;
      display: none; align-items: center; justify-content: center; flex-direction: column;
      background: rgba(0,0,0,0.78);
      color: #ff5151; text-shadow: 0 0 12px #f33;
      font-size: 2em; z-index: 9;
    }
    #gameOver small { font-size: .55em; color: #ccc; text-shadow: none; margin-top: 8px; }

    /* Side text */
    .side-text {
      position: absolute; top: 50%; transform: translateY(-50%);
      font-size: 2em; font-weight: 700; color: #f0f;
      text-shadow: 0 0 18px #f0f, 0 0 36px #90f;
      animation: sidePulse 2s infinite alternate;
      writing-mode: vertical-rl;
      z-index: 1; pointer-events: none;
    }
    .side-text.right { right: 15px; writing-mode: vertical-lr; }
    .side-text.left { left: 15px; }
    @keyframes sidePulse {
      0% { transform: translateY(-50%) scale(1); }
      100% { transform: translateY(-50%) scale(1.2); }
    }
  </style>
</head>
<body>
  <!-- Intro -->
  <div id="overlay">
    <h1>Meme Invaders!</h1>
    <div id="pressStart">Press Start to begin</div>
  </div>

  <!-- HUD -->
  <div id="scoreBoard">Score: 0 | Highscore: 0</div>
  <div id="waveBoard">Wave: 1</div>
  <div id="bossHP">Boss HP: 100%</div>

  <!-- Side labels -->
  <div class="side-text left">COBIE IS A MEME</div>
  <div class="side-text right">COBIE IS A MEME</div>

  <!-- Game Over -->
  <div id="gameOver">
    <div>GAME OVER</div>
    <small>Press Enter to return to Title</small>
  </div>

  <canvas id="game" width="800" height="600"></canvas>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const overlay = document.getElementById('overlay');
    const gameOverEl = document.getElementById('gameOver');
    const scoreEl = document.getElementById('scoreBoard');
    const waveEl = document.getElementById('waveBoard');
    const bossHPEl = document.getElementById('bossHP');

    // State
    let running = false, gameOver = false;
    let score = 0, highscore = Number(localStorage.getItem('memeHighscore')||0);
    let wave = 1;

    // Player
    const player = {
      x: canvas.width/2 - 20,
      y: canvas.height - 90,
      w: 40, h: 40,
      emoji: 'ðŸ’¥',
      speed: 6,
      shootCooldown: 220,   // ms
      nextShotAt: 0
    };

    // Entities
    let stars = [];
    let bullets = [];       // {x,y,vy}
    let enemies = [];       // {x,y,w,h,emoji}
    let enemyBullets = [];  // {x,y,vy}
    let boss = null;

    // Controls
    const keys = {};
    document.addEventListener('keydown', (e)=>{
      keys[e.code] = true;
      if (!running && !gameOver && e.code === 'Enter') startGame();
      if (gameOver && e.code === 'Enter') { showTitle(); }
    });
    document.addEventListener('keyup', (e)=>{ keys[e.code] = false; });
    overlay.addEventListener('click', startGame);
    gameOverEl.addEventListener('click', showTitle);

    // Init stars
    for(let i=0;i<110;i++){
      stars.push({x:Math.random()*canvas.width, y:Math.random()*canvas.height, a:Math.random()});
    }

    function showTitle(){
      gameOver = false;
      overlay.style.display = 'flex';
      gameOverEl.style.display = 'none';
    }

    function startGame(){
      overlay.style.display = 'none';
      gameOverEl.style.display = 'none';
      running = true;
      gameOver = false;

      score = 0;
      wave = 1;
      bullets = [];
      enemyBullets = [];
      boss = null;

      player.x = canvas.width/2 - player.w/2;
      player.y = canvas.height - 90;
      player.nextShotAt = 0;

      spawnEnemies();
      loop();
    }

    function endGame(){
      running = false;
      gameOver = true;
      if (score > highscore) {
        highscore = score;
        localStorage.setItem('memeHighscore', String(highscore));
      }
      updateHUD();
      gameOverEl.style.display = 'flex';
    }

    // Spawning
    const enemyChoices = ['ðŸ˜ˆ','ðŸ‘¹','ðŸ‘º','ðŸ¤¡','ðŸ‘¾'];
    function spawnEnemies(){
      enemies = [];
      const rows = 3, cols = 8;
      for (let r=0; r<rows; r++){
        for (let c=0; c<cols; c++){
          enemies.push({
            x: 80 + c*70,
            y: 60 + r*60,
            w: 40, h: 40,
            emoji: enemyChoices[Math.floor(Math.random()*enemyChoices.length)]
          });
        }
      }
    }

    function spawnBoss(){
      const bossEmojis = ['ðŸ˜ˆ','ðŸ‘¹','ðŸ¤¡','ðŸ‘º','ðŸ’°'];
      const modeByWave = ['pendulum','teleport','jerky','mix','chaos'];
      const attackByWave = ['single','fast','double','triple','mix'];

      const idx = (wave-1) % 5;
      const hpBase = 120;
      const hp = Math.floor(hpBase * Math.pow(1.4, wave-1));

      boss = {
        x: canvas.width/2 - 50, y: 110,
        w: 100, h: 100,
        emoji: bossEmojis[idx],
        hp, maxHp: hp,
        mode: modeByWave[idx],
        attack: attackByWave[idx],
        dir: 3,
        nextAct: 0,
        fireCD: 700,
        nextShotAt: 0
      };

      if (boss.attack === 'fast') boss.fireCD = 420;
      if (boss.attack === 'double') boss.fireCD = 620;
      if (boss.attack === 'triple') boss.fireCD = 700;
      if (boss.attack === 'mix') boss.fireCD = 520;

      bossHPEl.style.display = 'block';
      updateBossHPUI();
    }

    // HUD
    function updateHUD(){
      scoreEl.textContent = `Score: ${score} | Highscore: ${highscore}`;
      waveEl.textContent = `Wave: ${wave}`;
    }
    function updateBossHPUI(){
      if (!boss) { bossHPEl.style.display='none'; return; }
      const pct = Math.max(0, Math.floor(100*boss.hp/boss.maxHp));
      bossHPEl.textContent = `Boss HP: ${pct}%`;
    }

    // Drawing
    function drawStars(){
      for (const s of stars){
        s.a += (Math.random()-0.5)*0.12;
        if (s.a < 0.15) s.a = 0.15;
        if (s.a > 1.0) s.a = 1.0;
        ctx.fillStyle = `rgba(255,255,255,${s.a})`;
        ctx.fillRect(s.x, s.y, 2, 2);
      }
    }
    function drawPlanet(){
      const wobble = Math.sin(Date.now()/2000)*18;
      ctx.beginPath();
      ctx.arc(canvas.width/2 + wobble, canvas.height+210, 420, Math.PI, 2*Math.PI);
      ctx.fillStyle = 'rgba(0,120,255,0.28)';
      ctx.fill();
    }
    function drawPlayer(){
      ctx.font = '36px serif';
      ctx.fillText(player.emoji, player.x, player.y + player.h);
    }
    function drawEnemies(){
      ctx.font = '32px serif';
      for (const e of enemies){
        ctx.fillText(e.emoji, e.x, e.y);
      }
    }
    function drawBoss(){
      if (!boss) return;
      ctx.font = '90px serif';
      ctx.fillText(boss.emoji, boss.x, boss.y);
    }
    function drawBullets(){
      for (const b of bullets){
        ctx.fillStyle = 'red';
        ctx.shadowColor = 'red';
        ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.arc(b.x, b.y, 4, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
      }
      ctx.fillStyle = 'magenta';
      for (const eb of enemyBullets){
        ctx.fillRect(eb.x-1.5, eb.y, 3, 14);
      }
    }

    // Update
    function updatePlayer(){
      if (keys['ArrowLeft'] && player.x > 4) player.x -= player.speed;
      if (keys['ArrowRight'] && player.x + player.w < canvas.width-4) player.x += player.speed;

      if (keys['Space'] || keys['KeyZ']){
        const now = performance.now();
        if (now >= player.nextShotAt){
          bullets.push({x: player.x + player.w/2, y: player.y, vy: -9});
          player.nextShotAt = now + player.shootCooldown;
        }
      }
    }

    function updateEnemies(){
      const t = performance.now()/1000;
      for (const e of enemies){
        e.x += Math.sin(t * (1.2 + 0.15*wave) + e.y*0.05) * 0.9;
        e.y += Math.sin(t*0.7 + e.x*0.02) * 0.08;

        if (Math.random() < 0.0015 * (1 + 0.3*(wave-1))){
          enemyBullets.push({x: e.x + e.w/2, y: e.y + 8, vy: 2.5 + 0.25*wave});
        }

        if (e.y + e.h >= player.y) { endGame(); return; }
      }
    }

    function updateBoss(){
      if (!boss) return;
      const now = performance.now();

      if (boss.mode === 'pendulum'){
        boss.x += boss.dir;
        if (boss.x < 40 || boss.x + boss.w > canvas.width - 40) boss.dir *= -1;
      } else if (boss.mode === 'teleport'){
        if (now >= boss.nextAct){
          boss.x = 80 + Math.random()*(canvas.width-160);
          boss.nextAct = now + (900 - Math.min(600, wave*60));
        }
      } else if (boss.mode === 'jerky'){
        if (now >= boss.nextAct){
          boss.dir *= -1;
          boss.nextAct = now + (600 - Math.min(350, wave*40));
        }
        boss.x += boss.dir * (2 + 0.25*wave);
        if (boss.x < 60) { boss.x = 60; boss.dir = 1; }
        if (boss.x + boss.w > canvas.width-60) { boss.x = canvas.width-60-boss.w; boss.dir = -1; }
      } else if (boss.mode === 'mix'){
        if (Math.random() < 0.01) {
          boss.x = 80 + Math.random()*(canvas.width-160);
        } else {
          boss.x += boss.dir * (2 + 0.2*wave);
          if (boss.x < 60 || boss.x + boss.w > canvas.width-60) boss.dir *= -1;
        }
      } else if (boss.mode === 'chaos'){
        boss.x += (Math.random()*2-1) * (2 + 0.15*wave);
        if (Math.random() < 0.02) boss.x = 80 + Math.random()*(canvas.width-160);
        boss.x = Math.max(40, Math.min(canvas.width-40-boss.w, boss.x));
      }

      if (now >= boss.nextShotAt){
        const fire = (dxs, vy=4+0.25*wave)=>{ dxs.forEach(dx => enemyBullets.push({x: boss.x + boss.w/2 + dx*8, y: boss.y + boss.h/2, vy})); };

        if (boss.attack === 'single'){ fire([0], 4+0.2*wave); }
        else if (boss.attack === 'fast'){ fire([0], 5+0.35*wave); }
        else if (boss.attack === 'double'){ fire([-1,1], 4.5+0.25*wave); }
        else if (boss.attack === 'triple'){ fire([-1,0,1], 4.5+0.25*wave); }
        else if (boss.attack === 'mix'){
          const patterns = [[0],[-1,1],[-1,0,1]];
          fire(patterns[Math.floor(Math.random()*patterns.length)], 4.5+0.3*wave);
        }
        boss.nextShotAt = now + boss.fireCD * (0.85 + Math.random()*0.3);
      }
    }

    function updateBullets(){
      for (const b of bullets) b.y += b.vy;
      bullets = bullets.filter(b => b.y > -20);
      for (const eb of enemyBullets) eb.y += eb.vy;
      enemyBullets = enemyBullets.filter(eb => eb.y < canvas.height+20);
    }

    function handleCollisions(){
      for (const eb of enemyBullets){
        if (eb.x > player.x && eb.x < player.x + player.w &&
            eb.y > player.y && eb.y < player.y + player.h){
          endGame(); return;
        }
      }

      outer:
      for (let i=0;i<bullets.length;i++){
        const b = bullets[i];
        for (let j=0;j<enemies.length;j++){
          const e = enemies[j];
          if (b.x > e.x && b.x < e.x + e.w &&
              b.y > e.y && b.y < e.y + e.h){
            enemies.splice(j,1);
            bullets.splice(i,1);
            score += 10;
            updateHUD();
            break outer;
          }
        }
      }

      if (boss){
        for (let i=0;i<bullets.length;i++){
          const b = bullets[i];
          if (b.x > boss.x && b.x < boss.x + boss.w &&
              b.y > boss.y - 10 && b.y < boss.y + boss.h){
            bullets.splice(i,1);
            boss.hp -= 6;
            updateBossHPUI();
            if (boss.hp <= 0){
              score += 120 + wave*15;
              updateHUD();
              boss = null;
              bossHPEl.style.display = 'none';
              wave++;
              if (wave > 5){
                alert('âœ¨ YOU SAVED THE MEMES! âœ¨');
                endGame();
              } else {
                spawnEnemies();
              }
            }
            break;
          }
        }
      }
    }

    function loop(){
      if (!running) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawStars(); drawPlanet();
      updatePlayer(); drawPlayer();
      if (enemies.length){ updateEnemies(); drawEnemies(); }
      else if (!boss){ spawnBoss(); }
      updateBoss();
      updateBullets(); drawBullets(); handleCollisions();
      drawBoss();
      requestAnimationFrame(loop);
    }

    updateHUD();
  </script>
</body>
</html>
